<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · SpinDoctor.jl</title><script data-outdated-warner src="assets/warner.js"></script><link rel="canonical" href="https://agdestein.github.io/SpinDoctor.jl/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>SpinDoctor.jl</a></span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/agdestein/SpinDoctor.jl/blob/master/docs/src/index.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="SpinDoctor"><a class="docs-heading-anchor" href="#SpinDoctor">SpinDoctor</a><a id="SpinDoctor-1"></a><a class="docs-heading-anchor-permalink" href="#SpinDoctor" title="Permalink"></a></h1><p>Documentation for <a href="https://github.com/agdestein/SpinDoctor.jl">SpinDoctor</a>.</p><ul><li><a href="#SpinDoctor.SpinDoctor"><code>SpinDoctor.SpinDoctor</code></a></li><li><a href="#SpinDoctor.AbstractCallback"><code>SpinDoctor.AbstractCallback</code></a></li><li><a href="#SpinDoctor.AbstractGradient"><code>SpinDoctor.AbstractGradient</code></a></li><li><a href="#SpinDoctor.CosOGSE"><code>SpinDoctor.CosOGSE</code></a></li><li><a href="#SpinDoctor.DoublePGSE"><code>SpinDoctor.DoublePGSE</code></a></li><li><a href="#SpinDoctor.GeneralGradient"><code>SpinDoctor.GeneralGradient</code></a></li><li><a href="#SpinDoctor.Model"><code>SpinDoctor.Model</code></a></li><li><a href="#SpinDoctor.PGSE"><code>SpinDoctor.PGSE</code></a></li><li><a href="#SpinDoctor.Plotter"><code>SpinDoctor.Plotter</code></a></li><li><a href="#SpinDoctor.Printer"><code>SpinDoctor.Printer</code></a></li><li><a href="#SpinDoctor.ScalarGradient"><code>SpinDoctor.ScalarGradient</code></a></li><li><a href="#SpinDoctor.SinOGSE"><code>SpinDoctor.SinOGSE</code></a></li><li><a href="#SpinDoctor.TimeProfile-Tuple{Any}"><code>SpinDoctor.TimeProfile</code></a></li><li><a href="#SpinDoctor.TimeProfile"><code>SpinDoctor.TimeProfile</code></a></li><li><a href="#SpinDoctor.VTKWriter"><code>SpinDoctor.VTKWriter</code></a></li><li><a href="#SpinDoctor.assemble_flux_matrices-Tuple{Any, Any}"><code>SpinDoctor.assemble_flux_matrices</code></a></li><li><a href="#SpinDoctor.assemble_flux_matrix"><code>SpinDoctor.assemble_flux_matrix</code></a></li><li><a href="#SpinDoctor.assemble_mass_matrix"><code>SpinDoctor.assemble_mass_matrix</code></a></li><li><a href="#SpinDoctor.assemble_matrices-Tuple{Any}"><code>SpinDoctor.assemble_matrices</code></a></li><li><a href="#SpinDoctor.assemble_stiffness_matrix"><code>SpinDoctor.assemble_stiffness_matrix</code></a></li><li><a href="#SpinDoctor.call_tetgen"><code>SpinDoctor.call_tetgen</code></a></li><li><a href="#SpinDoctor.coefficients-Union{Tuple{AbstractSetup{T}}, Tuple{T}} where T"><code>SpinDoctor.coefficients</code></a></li><li><a href="#SpinDoctor.compute_areas-Tuple{Any, Any}"><code>SpinDoctor.compute_areas</code></a></li><li><a href="#SpinDoctor.compute_mf_diffusion_tensor"><code>SpinDoctor.compute_mf_diffusion_tensor</code></a></li><li><a href="#SpinDoctor.compute_signal-Tuple{Any, Any}"><code>SpinDoctor.compute_signal</code></a></li><li><a href="#SpinDoctor.compute_∇φ-Tuple{Any, Any}"><code>SpinDoctor.compute_∇φ</code></a></li><li><a href="#SpinDoctor.convexhull-Tuple{Any}"><code>SpinDoctor.convexhull</code></a></li><li><a href="#SpinDoctor.couple_flux_matrix"><code>SpinDoctor.couple_flux_matrix</code></a></li><li><a href="#SpinDoctor.create_cells-Tuple{Any}"><code>SpinDoctor.create_cells</code></a></li><li><a href="#SpinDoctor.create_fibonacci_sphere-Tuple{Any}"><code>SpinDoctor.create_fibonacci_sphere</code></a></li><li><a href="#SpinDoctor.create_geometry-Tuple{Any}"><code>SpinDoctor.create_geometry</code></a></li><li><a href="#SpinDoctor.create_surfaces-Tuple{CylinderSetup, Any}"><code>SpinDoctor.create_surfaces</code></a></li><li><a href="#SpinDoctor.create_surfaces-Tuple{NeuronSetup, Any}"><code>SpinDoctor.create_surfaces</code></a></li><li><a href="#SpinDoctor.create_surfaces-Tuple{SphereSetup, Any}"><code>SpinDoctor.create_surfaces</code></a></li><li><a href="#SpinDoctor.echotime-Tuple{GeneralGradient}"><code>SpinDoctor.echotime</code></a></li><li><a href="#SpinDoctor.echotime-Tuple{SpinDoctor.TimeProfile}"><code>SpinDoctor.echotime</code></a></li><li><a href="#SpinDoctor.eig2length-Tuple{Any, Any}"><code>SpinDoctor.eig2length</code></a></li><li><a href="#SpinDoctor.fit_adc-Tuple{Any, Any}"><code>SpinDoctor.fit_adc</code></a></li><li><a href="#SpinDoctor.fit_tensors-Tuple{Any, Any}"><code>SpinDoctor.fit_tensors</code></a></li><li><a href="#SpinDoctor.get_cmpt_volumes-Tuple{Any}"><code>SpinDoctor.get_cmpt_volumes</code></a></li><li><a href="#SpinDoctor.get_mesh_surface-Tuple{Any, Any}"><code>SpinDoctor.get_mesh_surface</code></a></li><li><a href="#SpinDoctor.get_mesh_surfacenormals-Tuple{Any, Any, Any}"><code>SpinDoctor.get_mesh_surfacenormals</code></a></li><li><a href="#SpinDoctor.get_mesh_volumes-Tuple{Any, Any}"><code>SpinDoctor.get_mesh_volumes</code></a></li><li><a href="#SpinDoctor.gmesh2fem-Tuple{Any}"><code>SpinDoctor.gmesh2fem</code></a></li><li><a href="#SpinDoctor.int_F²-Union{Tuple{SpinDoctor.TimeProfile{T}}, Tuple{T}} where T"><code>SpinDoctor.int_F²</code></a></li><li><a href="#SpinDoctor.integral"><code>SpinDoctor.integral</code></a></li><li><a href="#SpinDoctor.intervals"><code>SpinDoctor.intervals</code></a></li><li><a href="#SpinDoctor.isconstant-Tuple{SpinDoctor.TimeProfile}"><code>SpinDoctor.isconstant</code></a></li><li><a href="#SpinDoctor.length2eig-Tuple{Any, Any}"><code>SpinDoctor.length2eig</code></a></li><li><a href="#SpinDoctor.limit_lengthscale-Tuple{Any, Any}"><code>SpinDoctor.limit_lengthscale</code></a></li><li><a href="#SpinDoctor.output_type"><code>SpinDoctor.output_type</code></a></li><li><a href="#SpinDoctor.plot_field-Tuple{SpinDoctor.FEMesh, Any}"><code>SpinDoctor.plot_field</code></a></li><li><a href="#SpinDoctor.plot_mesh-Tuple{SpinDoctor.FEMesh}"><code>SpinDoctor.plot_mesh</code></a></li><li><a href="#SpinDoctor.radial_dimension"><code>SpinDoctor.radial_dimension</code></a></li><li><a href="#SpinDoctor.read_cells-Tuple{Any}"><code>SpinDoctor.read_cells</code></a></li><li><a href="#SpinDoctor.read_surfaces-Tuple{Any}"><code>SpinDoctor.read_surfaces</code></a></li><li><a href="#SpinDoctor.read_tetgen-Tuple{Any}"><code>SpinDoctor.read_tetgen</code></a></li><li><a href="#SpinDoctor.save_cells-Tuple{Any, Any}"><code>SpinDoctor.save_cells</code></a></li><li><a href="#SpinDoctor.save_surfaces-Tuple{Any, Any}"><code>SpinDoctor.save_surfaces</code></a></li><li><a href="#SpinDoctor.save_tetgen-Tuple{Any, Any}"><code>SpinDoctor.save_tetgen</code></a></li><li><a href="#SpinDoctor.shapeder-Tuple{Any}"><code>SpinDoctor.shapeder</code></a></li><li><a href="#SpinDoctor.solve-Tuple{Laplace}"><code>SpinDoctor.solve</code></a></li><li><a href="#SpinDoctor.solve-Union{Tuple{T}, Tuple{GeneralBTPDE{T}, Any}} where T"><code>SpinDoctor.solve</code></a></li><li><a href="#SpinDoctor.solve-Tuple{AnalyticalMatrixFormalism, Any}"><code>SpinDoctor.solve</code></a></li><li><a href="#SpinDoctor.solve-Tuple{Karger, ScalarGradient}"><code>SpinDoctor.solve</code></a></li><li><a href="#SpinDoctor.solve-Tuple{MatrixFormalism, Any}"><code>SpinDoctor.solve</code></a></li><li><a href="#SpinDoctor.solve-Union{Tuple{T}, Tuple{IntervalConstanBTPDE{T}, ScalarGradient}} where T"><code>SpinDoctor.solve</code></a></li><li><a href="#SpinDoctor.solve"><code>SpinDoctor.solve</code></a></li><li><a href="#SpinDoctor.solve-Tuple{HADC, ScalarGradient}"><code>SpinDoctor.solve</code></a></li><li><a href="#SpinDoctor.solve_multigrad-Tuple{Any, Any}"><code>SpinDoctor.solve_multigrad</code></a></li><li><a href="#SpinDoctor.split_field-Tuple{Any, Any}"><code>SpinDoctor.split_field</code></a></li><li><a href="#SpinDoctor.unitcircle-Tuple{Any}"><code>SpinDoctor.unitcircle</code></a></li><li><a href="#SpinDoctor.unitsphere-Tuple{Any}"><code>SpinDoctor.unitsphere</code></a></li></ul><article class="docstring"><header><a class="docstring-binding" id="SpinDoctor.SpinDoctor" href="#SpinDoctor.SpinDoctor"><code>SpinDoctor.SpinDoctor</code></a> — <span class="docstring-category">Module</span></header><section><div><p>Diffusion MRI modelling</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/agdestein/SpinDoctor.jl/blob/5f9f3fc2bf0af9125f6c56fd3d69075b6099e499/src/SpinDoctor.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpinDoctor.AbstractCallback" href="#SpinDoctor.AbstractCallback"><code>SpinDoctor.AbstractCallback</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractCallback</code></pre><p>Callback to be performed after every time step when solving the BTPDE. The callback is initialized before time stepping using the <code>initialize!</code> function, updated after every step using <code>update!</code>, and finalized after time stepping using <code>finalize!</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/agdestein/SpinDoctor.jl/blob/5f9f3fc2bf0af9125f6c56fd3d69075b6099e499/src/callbacks/callbacks.jl#L1-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpinDoctor.AbstractGradient" href="#SpinDoctor.AbstractGradient"><code>SpinDoctor.AbstractGradient</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractGradient{T}</code></pre><p>Magnetic field gradient <span>$\vec{g}(t)$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/agdestein/SpinDoctor.jl/blob/5f9f3fc2bf0af9125f6c56fd3d69075b6099e499/src/gradients/gradient.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpinDoctor.CosOGSE" href="#SpinDoctor.CosOGSE"><code>SpinDoctor.CosOGSE</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">f = CosOGSE(δ, Δ, nperiod)</code></pre><p>Oscillating Gradient Spin Echo sequence with two cos-pulses of duration <code>δ</code> separated by a pause of duration <code>Δ-δ</code> for <code>nperiod</code> periods per pulse.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/agdestein/SpinDoctor.jl/blob/5f9f3fc2bf0af9125f6c56fd3d69075b6099e499/src/gradients/sequences.jl#L29-L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpinDoctor.DoublePGSE" href="#SpinDoctor.DoublePGSE"><code>SpinDoctor.DoublePGSE</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">f = DoublePGSE(δ, Δ)</code></pre><p>Double Pulsed Gradient Spin Echo sequence with four pulses of duration <code>δ</code>, separated by pauses of duration <code>Δ-δ</code>, <code>0</code>, and <code>Δ-δ</code> repsectively.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/agdestein/SpinDoctor.jl/blob/5f9f3fc2bf0af9125f6c56fd3d69075b6099e499/src/gradients/sequences.jl#L63-L68">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpinDoctor.GeneralGradient" href="#SpinDoctor.GeneralGradient"><code>SpinDoctor.GeneralGradient</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">GeneralGradient(g⃗)</code></pre><p>General gradient sequence <code>g⃗(t) ∈ R³</code>. The direction and amplitude may vary in time.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/agdestein/SpinDoctor.jl/blob/5f9f3fc2bf0af9125f6c56fd3d69075b6099e499/src/gradients/gradient.jl#L8-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpinDoctor.Model" href="#SpinDoctor.Model"><code>SpinDoctor.Model</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Model(mesh, ρ, D, T₂, κ, γ)</code></pre><p>Discretized biological model with initial spin densities <code>ρ</code>, diffusion tensors <code>D</code>, T₂-relaxation times <code>T₂</code>, wall permeabilities <code>κ</code>, and gyromacnetic ratio <code>γ</code> (defaults to the one of water protons).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/agdestein/SpinDoctor.jl/blob/5f9f3fc2bf0af9125f6c56fd3d69075b6099e499/src/datatypes/model.jl#L1-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpinDoctor.PGSE" href="#SpinDoctor.PGSE"><code>SpinDoctor.PGSE</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">f = PGSE(δ, Δ)</code></pre><p>Pulsed Gradient Spin Echo sequence with pulse duration <code>δ</code> and time between pulses <code>Δ-δ</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/agdestein/SpinDoctor.jl/blob/5f9f3fc2bf0af9125f6c56fd3d69075b6099e499/src/gradients/sequences.jl#L14-L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpinDoctor.Plotter" href="#SpinDoctor.Plotter"><code>SpinDoctor.Plotter</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Plotter(; nupdate = 1)</code></pre><p>Plot the evolution of the BTPDE during time stepping. This requires loading the <code>GLMakie</code> plotting backend (<code>]add GLMakie; using GLMakie</code>). The plot is updated every <code>nupdate</code> time step. The resulting figure contains a plot of the time profile, total signal attenuation, and magnetization field (complex magnitude and phase shift).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/agdestein/SpinDoctor.jl/blob/5f9f3fc2bf0af9125f6c56fd3d69075b6099e499/src/callbacks/callbacks.jl#L37-L44">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpinDoctor.Printer" href="#SpinDoctor.Printer"><code>SpinDoctor.Printer</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Printer(; nupdate = 1)</code></pre><p>Print time stepping information to the console.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/agdestein/SpinDoctor.jl/blob/5f9f3fc2bf0af9125f6c56fd3d69075b6099e499/src/callbacks/callbacks.jl#L10-L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpinDoctor.ScalarGradient" href="#SpinDoctor.ScalarGradient"><code>SpinDoctor.ScalarGradient</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ScalarGradient(dir, profile, amplitude)</code></pre><p>Gradient sequence with amplitude <code>amplitude</code>, normal direction <code>dir</code> and scalar time profile <code>profile</code>.</p><p>The direction is constant, while the amplitude is controlled by the time profile.</p><p>The direction is normalized upon construction.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/agdestein/SpinDoctor.jl/blob/5f9f3fc2bf0af9125f6c56fd3d69075b6099e499/src/gradients/gradient.jl#L18-L27">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpinDoctor.SinOGSE" href="#SpinDoctor.SinOGSE"><code>SpinDoctor.SinOGSE</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">f = SinOGSE(δ, Δ, nperiod)</code></pre><p>Oscillating Gradient Spin Echo sequence with two sin-pulses of duration <code>δ</code> separated by a pause of duration <code>Δ-δ</code> for <code>nperiod</code> periods per pulse.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/agdestein/SpinDoctor.jl/blob/5f9f3fc2bf0af9125f6c56fd3d69075b6099e499/src/gradients/sequences.jl#L46-L51">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpinDoctor.TimeProfile" href="#SpinDoctor.TimeProfile"><code>SpinDoctor.TimeProfile</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">TimeProfile</code></pre><p>General time profile type (gradient sequence).</p><p>A <code>TimeProfile</code> should implement a calling method returning the value of the time profile at time <code>t</code>. It can optionally overwrite the <code>echotime</code> <code>integral</code>, and <code>int_F²</code> methods, the first providing a default value and the latter two computing numerical approximation to the integral quantities if not overwritten.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/agdestein/SpinDoctor.jl/blob/5f9f3fc2bf0af9125f6c56fd3d69075b6099e499/src/gradients/sequences.jl#L1-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpinDoctor.TimeProfile-Tuple{Any}" href="#SpinDoctor.TimeProfile-Tuple{Any}"><code>SpinDoctor.TimeProfile</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ft = (f::TimeProfile)(t)</code></pre><p>Return the time profile value at time <code>t</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/agdestein/SpinDoctor.jl/blob/5f9f3fc2bf0af9125f6c56fd3d69075b6099e499/src/gradients/sequences.jl#L81-L85">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpinDoctor.VTKWriter" href="#SpinDoctor.VTKWriter"><code>SpinDoctor.VTKWriter</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">VTKWriter(; nupdate = 1, dir = &quot;output&quot;, filename = &quot;solution&quot;)</code></pre><p>Write magnetization field to a VTK file after every <code>nupdate</code> timestep. The files are stored in a ParaView data collection file (PVD). The magnetization time series may be visualized in ParaView by opening the file <code>&quot;$dir/$filename.pvd&quot;</code>. The compartments are labeled.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/agdestein/SpinDoctor.jl/blob/5f9f3fc2bf0af9125f6c56fd3d69075b6099e499/src/callbacks/callbacks.jl#L21-L27">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpinDoctor.assemble_flux_matrices-Tuple{Any, Any}" href="#SpinDoctor.assemble_flux_matrices-Tuple{Any, Any}"><code>SpinDoctor.assemble_flux_matrices</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">assemble_flux_matrices(points, facets)</code></pre><p>Assemble flux matrix (<code>Q</code>) for each compartment and boundary.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/agdestein/SpinDoctor.jl/blob/5f9f3fc2bf0af9125f6c56fd3d69075b6099e499/src/matrix_assembly/assemble_flux_matrices.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpinDoctor.assemble_flux_matrix" href="#SpinDoctor.assemble_flux_matrix"><code>SpinDoctor.assemble_flux_matrix</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">assemble_flux_matrix(facets, nodes[, weights])</code></pre><p>Assemble 3D flux matrix using P1 finite elements.</p><p>This function is based on the Matlab function <code>flux_matrixP1_3D.m</code> from the Matlab nodal matrix assembly toolbox by Jan Valdman and Talal Rahman.</p><p>https://uk.mathworks.com/matlabcentral/fileexchange/27826-fast-fem-assembly-nodal-elements</p><p>Talal Rahman and Jan Valdman: Fast MATLAB assembly of FEM matrices in 2D and 3D: nodal elements, Applied Mathematics and Computation 219, 7151–7158 (2013).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/agdestein/SpinDoctor.jl/blob/5f9f3fc2bf0af9125f6c56fd3d69075b6099e499/src/matrix_assembly/assemble_flux_matrix.jl#L1-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpinDoctor.assemble_mass_matrix" href="#SpinDoctor.assemble_mass_matrix"><code>SpinDoctor.assemble_mass_matrix</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">assemble_mass_matrix(elements, volumes[, weights])</code></pre><p>Assemble 3D mass matrix using P1 finite elements.</p><p>This function is based on the Matlab function <code>mass_matrixP1_3D.m</code> from the Matlab nodal matrix assembly toolbox by Jan Valdman and Talal Rahmnan:</p><p>https://uk.mathworks.com/matlabcentral/fileexchange/27826-fast-fem-assembly-nodal-elements</p><p>Talal Rahman and Jan Valdman: Fast MATLAB assembly of FEM matrices in 2D and 3D: nodal elements, Applied Mathematics and Computation 219, 7151–7158 (2013).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/agdestein/SpinDoctor.jl/blob/5f9f3fc2bf0af9125f6c56fd3d69075b6099e499/src/matrix_assembly/assemble_mass_matrix.jl#L1-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpinDoctor.assemble_matrices-Tuple{Any}" href="#SpinDoctor.assemble_matrices-Tuple{Any}"><code>SpinDoctor.assemble_matrices</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">assemble_matrices(model)</code></pre><p>Assemble finite element matrices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/agdestein/SpinDoctor.jl/blob/5f9f3fc2bf0af9125f6c56fd3d69075b6099e499/src/matrix_assembly/assemble_matrices.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpinDoctor.assemble_stiffness_matrix" href="#SpinDoctor.assemble_stiffness_matrix"><code>SpinDoctor.assemble_stiffness_matrix</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">assemble_stiffness_matrix(elements, nodes[, D])</code></pre><p>Assemble 3D stiffness matrix using P1 finite elements. A diffusion tensor <code>D</code> may be provided.</p><p>This function is based on the Matlab function <code>stiffness_matrixP1_3D.m</code> from the Matlab nodal matrix assembly toolbox by Jan Valdman and Talal Rahman.</p><p>https://uk.mathworks.com/matlabcentral/fileexchange/27826-fast-fem-assembly-nodal-elements</p><p>Talal Rahman and Jan Valdman: Fast MATLAB assembly of FEM matrices in 2D and 3D: nodal elements, Applied Mathematics and Computation 219, 7151–7158 (2013).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/agdestein/SpinDoctor.jl/blob/5f9f3fc2bf0af9125f6c56fd3d69075b6099e499/src/matrix_assembly/assemble_stiffness_matrix.jl#L1-L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpinDoctor.call_tetgen" href="#SpinDoctor.call_tetgen"><code>SpinDoctor.call_tetgen</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">call_tetgen(setup, surfaces)</code></pre><p>Call Tetgen on surface geometry.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/agdestein/SpinDoctor.jl/blob/5f9f3fc2bf0af9125f6c56fd3d69075b6099e499/src/geometry/call_tetgen.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpinDoctor.coefficients-Union{Tuple{AbstractSetup{T}}, Tuple{T}} where T" href="#SpinDoctor.coefficients-Union{Tuple{AbstractSetup{T}}, Tuple{T}} where T"><code>SpinDoctor.coefficients</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">coefficients(setup; D, T₂, ρ, κ, γ)</code></pre><p>Prepare PDE compartments.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/agdestein/SpinDoctor.jl/blob/5f9f3fc2bf0af9125f6c56fd3d69075b6099e499/src/recipes/coefficients.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpinDoctor.compute_areas-Tuple{Any, Any}" href="#SpinDoctor.compute_areas-Tuple{Any, Any}"><code>SpinDoctor.compute_areas</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">compute_areas(facets, nodes)</code></pre><p>Compute facet areas.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/agdestein/SpinDoctor.jl/blob/5f9f3fc2bf0af9125f6c56fd3d69075b6099e499/src/matrix_assembly/assemble_flux_matrix.jl#L42-L46">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpinDoctor.compute_mf_diffusion_tensor" href="#SpinDoctor.compute_mf_diffusion_tensor"><code>SpinDoctor.compute_mf_diffusion_tensor</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">compute_mf_diffusion_tensor</code></pre><p>Compute an effective diffusion tensors using the matrix formalism.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/agdestein/SpinDoctor.jl/blob/5f9f3fc2bf0af9125f6c56fd3d69075b6099e499/src/matrix_formalism/compute_mf_diffusion_tensor.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpinDoctor.compute_signal-Tuple{Any, Any}" href="#SpinDoctor.compute_signal-Tuple{Any, Any}"><code>SpinDoctor.compute_signal</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">compute_signal(M, ξ) = sum(M * ξ)</code></pre><p>Compute signal from magnetization <code>ξ</code>, using the mass matrix <code>M</code> for integration.</p><p>Given a mesh <code>mesh</code> and a vector of compartment mass matrices <code>M_cmpts</code>, a vector of compartment signals may be obtained by <code>compute_signal.(M_cmpts, split_field(mesh, ξ))</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/agdestein/SpinDoctor.jl/blob/5f9f3fc2bf0af9125f6c56fd3d69075b6099e499/src/utils/compute_signal.jl#L1-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpinDoctor.compute_∇φ-Tuple{Any, Any}" href="#SpinDoctor.compute_∇φ-Tuple{Any, Any}"><code>SpinDoctor.compute_∇φ</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">compute_∇φ(nodes, points)</code></pre><p>Compute the gradients of the finite element basis functions φ.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/agdestein/SpinDoctor.jl/blob/5f9f3fc2bf0af9125f6c56fd3d69075b6099e499/src/matrix_assembly/assemble_stiffness_matrix.jl#L38-L42">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpinDoctor.convexhull-Tuple{Any}" href="#SpinDoctor.convexhull-Tuple{Any}"><code>SpinDoctor.convexhull</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">elements, points = convexhull(points)</code></pre><p>Compute the convex hull of a set of points <code>points</code> (of size <code>dim * npoint</code>). Return a matrix of boundary elements <code>elements</code> (of size<code>dim * nelement</code>) and a restriction of the original points to the boundary (size <code>dim * npoint_keep</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/agdestein/SpinDoctor.jl/blob/5f9f3fc2bf0af9125f6c56fd3d69075b6099e499/src/geometry/convexhull.jl#L1-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpinDoctor.couple_flux_matrix" href="#SpinDoctor.couple_flux_matrix"><code>SpinDoctor.couple_flux_matrix</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">couple_flux_matrix(model, Q_blocks[, symmetrical])</code></pre><p>Create global flux matrix with coupling between compartments.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/agdestein/SpinDoctor.jl/blob/5f9f3fc2bf0af9125f6c56fd3d69075b6099e499/src/matrix_assembly/couple_flux_matrix.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpinDoctor.create_cells-Tuple{Any}" href="#SpinDoctor.create_cells-Tuple{Any}"><code>SpinDoctor.create_cells</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">create_cells(setup)</code></pre><p>Create geometrical configuration of cells. Return mathematical description (radii, centers).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/agdestein/SpinDoctor.jl/blob/5f9f3fc2bf0af9125f6c56fd3d69075b6099e499/src/geometry/create_cells.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpinDoctor.create_fibonacci_sphere-Tuple{Any}" href="#SpinDoctor.create_fibonacci_sphere-Tuple{Any}"><code>SpinDoctor.create_fibonacci_sphere</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">create_fibonacci_sphere(npoint)</code></pre><p>Create <code>npoint</code> evenly distributed points on the sphere.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/agdestein/SpinDoctor.jl/blob/5f9f3fc2bf0af9125f6c56fd3d69075b6099e499/src/geometry/create_fibonacci_sphere.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpinDoctor.create_geometry-Tuple{Any}" href="#SpinDoctor.create_geometry-Tuple{Any}"><code>SpinDoctor.create_geometry</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">create_geometry(setup)</code></pre><p>Create cells, surfaces and finite element mesh. This function does the following:</p><ul><li>Check geometry setup consistency</li><li>Create or load cell configuration</li><li>Create or load surface triangulation</li><li>Call TetGen</li><li>Deform domain</li><li>Split mesh into compartments</li></ul><p>For custom geometries with more than one compartment, call <code>split_mesh</code> directly instead. This requires facet and element labels.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/agdestein/SpinDoctor.jl/blob/5f9f3fc2bf0af9125f6c56fd3d69075b6099e499/src/recipes/create_geometry.jl#L1-L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpinDoctor.create_surfaces-Tuple{CylinderSetup, Any}" href="#SpinDoctor.create_surfaces-Tuple{CylinderSetup, Any}"><code>SpinDoctor.create_surfaces</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">create_surfaces(setup::CylinderSetup, cells)</code></pre><p>Create surface triangulation of [inner and] outer cylinders [and ECS].</p><p>The ground surface is triangulated first, before the walls are &quot;extruded&quot; and the top surface is copied from the ground surface.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/agdestein/SpinDoctor.jl/blob/5f9f3fc2bf0af9125f6c56fd3d69075b6099e499/src/recipes/create_surfaces_cylinder.jl#L1-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpinDoctor.create_surfaces-Tuple{NeuronSetup, Any}" href="#SpinDoctor.create_surfaces-Tuple{NeuronSetup, Any}"><code>SpinDoctor.create_surfaces</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">create_surfaces(setup::NeuronSetup, filename)</code></pre><p>Create neuron surface mesh. A neuron surface mesh is loaded or create and loaded. An ECS can be added.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/agdestein/SpinDoctor.jl/blob/5f9f3fc2bf0af9125f6c56fd3d69075b6099e499/src/recipes/create_surfaces_neuron.jl#L1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpinDoctor.create_surfaces-Tuple{SphereSetup, Any}" href="#SpinDoctor.create_surfaces-Tuple{SphereSetup, Any}"><code>SpinDoctor.create_surfaces</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">create_surfaces(setup::SphereSetup, cells)</code></pre><p>Create surface triangulation of [inner and] outer spheres [and ECS].</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/agdestein/SpinDoctor.jl/blob/5f9f3fc2bf0af9125f6c56fd3d69075b6099e499/src/recipes/create_surfaces_sphere.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpinDoctor.echotime-Tuple{GeneralGradient}" href="#SpinDoctor.echotime-Tuple{GeneralGradient}"><code>SpinDoctor.echotime</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">echotime(gradient)</code></pre><p>Get echo time <code>TE</code> of <code>gradient</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/agdestein/SpinDoctor.jl/blob/5f9f3fc2bf0af9125f6c56fd3d69075b6099e499/src/gradients/echotime.jl#L9-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpinDoctor.echotime-Tuple{SpinDoctor.TimeProfile}" href="#SpinDoctor.echotime-Tuple{SpinDoctor.TimeProfile}"><code>SpinDoctor.echotime</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">echotime(f)</code></pre><p>Get echo time <code>TE</code> of the time profile <code>f</code>, which is the end of the last characteristic interval.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/agdestein/SpinDoctor.jl/blob/5f9f3fc2bf0af9125f6c56fd3d69075b6099e499/src/gradients/echotime.jl#L1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpinDoctor.eig2length-Tuple{Any, Any}" href="#SpinDoctor.eig2length-Tuple{Any, Any}"><code>SpinDoctor.eig2length</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">eig2length(λ, D)</code></pre><p>Convert Laplace eigenvalue to length scale.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/agdestein/SpinDoctor.jl/blob/5f9f3fc2bf0af9125f6c56fd3d69075b6099e499/src/matrix_formalism/eig2length.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpinDoctor.fit_adc-Tuple{Any, Any}" href="#SpinDoctor.fit_adc-Tuple{Any, Any}"><code>SpinDoctor.fit_adc</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">fit_adc(bvalues, signals)</code></pre><p>Fit the apparent diffusion coefficient (ADC) using a polynomial logfit of the normalized signals <code>signals</code> against the b-values <code>bvalues</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/agdestein/SpinDoctor.jl/blob/5f9f3fc2bf0af9125f6c56fd3d69075b6099e499/src/postprocess/fit_adc.jl#L1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpinDoctor.fit_tensors-Tuple{Any, Any}" href="#SpinDoctor.fit_tensors-Tuple{Any, Any}"><code>SpinDoctor.fit_tensors</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">fit_tensors(directions, adcs)</code></pre><p>Fit effective diffusion tensors to directionalized ADCs. The six components of the symmetric diffusion tensors are fitted by least squares to the gradient directions and resulting ADCs.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/agdestein/SpinDoctor.jl/blob/5f9f3fc2bf0af9125f6c56fd3d69075b6099e499/src/postprocess/fit_tensors.jl#L1-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpinDoctor.get_cmpt_volumes-Tuple{Any}" href="#SpinDoctor.get_cmpt_volumes-Tuple{Any}"><code>SpinDoctor.get_cmpt_volumes</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_cmpt_volumes(mesh)</code></pre><p>Get compartment volumes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/agdestein/SpinDoctor.jl/blob/5f9f3fc2bf0af9125f6c56fd3d69075b6099e499/src/geometry/get_volumes.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpinDoctor.get_mesh_surface-Tuple{Any, Any}" href="#SpinDoctor.get_mesh_surface-Tuple{Any, Any}"><code>SpinDoctor.get_mesh_surface</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_mesh_surface(points, facets)</code></pre><p>Compute surface areas, centers and normals for each facet.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/agdestein/SpinDoctor.jl/blob/5f9f3fc2bf0af9125f6c56fd3d69075b6099e499/src/geometry/get_mesh_surface.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpinDoctor.get_mesh_surfacenormals-Tuple{Any, Any, Any}" href="#SpinDoctor.get_mesh_surfacenormals-Tuple{Any, Any, Any}"><code>SpinDoctor.get_mesh_surfacenormals</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_mesh_surfacenormals(points, elements, facets)</code></pre><p>Computing outwards oriented surface normals on a connected mesh compartment.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/agdestein/SpinDoctor.jl/blob/5f9f3fc2bf0af9125f6c56fd3d69075b6099e499/src/geometry/get_mesh_surfacenormals.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpinDoctor.get_mesh_volumes-Tuple{Any, Any}" href="#SpinDoctor.get_mesh_volumes-Tuple{Any, Any}"><code>SpinDoctor.get_mesh_volumes</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_mesh_volumes(points, elements)</code></pre><p>Get total volume and volumes of each tetrahedron of mesh.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/agdestein/SpinDoctor.jl/blob/5f9f3fc2bf0af9125f6c56fd3d69075b6099e499/src/geometry/get_volumes.jl#L11-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpinDoctor.gmesh2fem-Tuple{Any}" href="#SpinDoctor.gmesh2fem-Tuple{Any}"><code>SpinDoctor.gmesh2fem</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">gmesh2fem(filename)</code></pre><p>Extract points and elements from Gmesh file.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/agdestein/SpinDoctor.jl/blob/5f9f3fc2bf0af9125f6c56fd3d69075b6099e499/src/geometry/gmesh2fem.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpinDoctor.int_F²-Union{Tuple{SpinDoctor.TimeProfile{T}}, Tuple{T}} where T" href="#SpinDoctor.int_F²-Union{Tuple{SpinDoctor.TimeProfile{T}}, Tuple{T}} where T"><code>SpinDoctor.int_F²</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">b = int_F²(f)</code></pre><p>Compute the time profile contribution to the b-value. To obtain the b-value, multiply the result by <code>q^2 = (γg)^2</code>, where <code>γ</code> is the gyromagnetic ratio of the water proton, <code>g</code> is the gradient amplitude, and <code>b = q^2 * int_F²(f)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/agdestein/SpinDoctor.jl/blob/5f9f3fc2bf0af9125f6c56fd3d69075b6099e499/src/gradients/int_F2.jl#L1-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpinDoctor.integral" href="#SpinDoctor.integral"><code>SpinDoctor.integral</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">integral(f, t = echotime(f))</code></pre><p>Integral of time profile <code>f</code> between <code>0</code> and <code>t</code>. Unless specified, the echotime is used as the upper integral limit.</p><p>For the <code>PGSE</code>, <code>SinOGSE</code>, <code>CosOGSE</code> and <code>DoublePGSE</code> sequences, analytical expressions are available. Otherwise a numerical integral is computed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/agdestein/SpinDoctor.jl/blob/5f9f3fc2bf0af9125f6c56fd3d69075b6099e499/src/gradients/integral.jl#L1-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpinDoctor.intervals" href="#SpinDoctor.intervals"><code>SpinDoctor.intervals</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">intervals(f)</code></pre><p>Get characteristic intervals of the time profile <code>f</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/agdestein/SpinDoctor.jl/blob/5f9f3fc2bf0af9125f6c56fd3d69075b6099e499/src/gradients/intervals.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpinDoctor.isconstant-Tuple{SpinDoctor.TimeProfile}" href="#SpinDoctor.isconstant-Tuple{SpinDoctor.TimeProfile}"><code>SpinDoctor.isconstant</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">isconstant(profile)</code></pre><p>Return <code>true</code> if the time profile <code>profile</code> is intervalwise constant.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/agdestein/SpinDoctor.jl/blob/5f9f3fc2bf0af9125f6c56fd3d69075b6099e499/src/gradients/isconstant.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpinDoctor.length2eig-Tuple{Any, Any}" href="#SpinDoctor.length2eig-Tuple{Any, Any}"><code>SpinDoctor.length2eig</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">length2eig(length, D)</code></pre><p>Convert length scale to Laplace eigenvalue.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/agdestein/SpinDoctor.jl/blob/5f9f3fc2bf0af9125f6c56fd3d69075b6099e499/src/matrix_formalism/eig2length.jl#L8-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpinDoctor.limit_lengthscale-Tuple{Any, Any}" href="#SpinDoctor.limit_lengthscale-Tuple{Any, Any}"><code>SpinDoctor.limit_lengthscale</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">limit_lengthscale(lap_eig, λ_max)</code></pre><p>Only keep modes with length scales larger than minimum</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/agdestein/SpinDoctor.jl/blob/5f9f3fc2bf0af9125f6c56fd3d69075b6099e499/src/matrix_formalism/limit_lengthscale.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpinDoctor.output_type" href="#SpinDoctor.output_type"><code>SpinDoctor.output_type</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">output_type(problem)</code></pre><p>Get type returned by <code>solve(problem)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/agdestein/SpinDoctor.jl/blob/5f9f3fc2bf0af9125f6c56fd3d69075b6099e499/src/problems/output_type.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpinDoctor.plot_field-Tuple{SpinDoctor.FEMesh, Any}" href="#SpinDoctor.plot_field-Tuple{SpinDoctor.FEMesh, Any}"><code>SpinDoctor.plot_field</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">plot_field(femesh, ξ)</code></pre><p>Plot field <code>ξ</code> on the finite element mesh.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/agdestein/SpinDoctor.jl/blob/5f9f3fc2bf0af9125f6c56fd3d69075b6099e499/src/plot/plot_field.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpinDoctor.plot_mesh-Tuple{SpinDoctor.FEMesh}" href="#SpinDoctor.plot_mesh-Tuple{SpinDoctor.FEMesh}"><code>SpinDoctor.plot_mesh</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">plot_mesh(femesh)</code></pre><p>Plot finite element mesh.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/agdestein/SpinDoctor.jl/blob/5f9f3fc2bf0af9125f6c56fd3d69075b6099e499/src/plot/plot_mesh.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpinDoctor.radial_dimension" href="#SpinDoctor.radial_dimension"><code>SpinDoctor.radial_dimension</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">radial_dimension(setup)</code></pre><p>Get dimension of radial direction.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/agdestein/SpinDoctor.jl/blob/5f9f3fc2bf0af9125f6c56fd3d69075b6099e499/src/recipes/radial_dimension.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpinDoctor.read_cells-Tuple{Any}" href="#SpinDoctor.read_cells-Tuple{Any}"><code>SpinDoctor.read_cells</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">read_cells(cellfilename)</code></pre><p>Read cell configuration (centers and radii).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/agdestein/SpinDoctor.jl/blob/5f9f3fc2bf0af9125f6c56fd3d69075b6099e499/src/geometry/read_cells.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpinDoctor.read_surfaces-Tuple{Any}" href="#SpinDoctor.read_surfaces-Tuple{Any}"><code>SpinDoctor.read_surfaces</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">read_surfaces(filename)</code></pre><p>Read surface triangulation from file.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/agdestein/SpinDoctor.jl/blob/5f9f3fc2bf0af9125f6c56fd3d69075b6099e499/src/geometry/read_surfaces.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpinDoctor.read_tetgen-Tuple{Any}" href="#SpinDoctor.read_tetgen-Tuple{Any}"><code>SpinDoctor.read_tetgen</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">read_tetgen</code></pre><p>Read mesh from Tetgen.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/agdestein/SpinDoctor.jl/blob/5f9f3fc2bf0af9125f6c56fd3d69075b6099e499/src/geometry/read_tetgen.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpinDoctor.save_cells-Tuple{Any, Any}" href="#SpinDoctor.save_cells-Tuple{Any, Any}"><code>SpinDoctor.save_cells</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">save_cells(cells, cellfilename)</code></pre><p>Write geometrical cell configuration to file. The file contains the spatial dimension: 2 for cylinders, 3 for spheres.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/agdestein/SpinDoctor.jl/blob/5f9f3fc2bf0af9125f6c56fd3d69075b6099e499/src/geometry/save_cells.jl#L1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpinDoctor.save_surfaces-Tuple{Any, Any}" href="#SpinDoctor.save_surfaces-Tuple{Any, Any}"><code>SpinDoctor.save_surfaces</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">save_surfaces(filename, surfaces)</code></pre><p>Save surface triangulation. The files may be passed to Tetgen with <code>filename</code>.node.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/agdestein/SpinDoctor.jl/blob/5f9f3fc2bf0af9125f6c56fd3d69075b6099e499/src/geometry/save_surfaces.jl#L1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpinDoctor.save_tetgen-Tuple{Any, Any}" href="#SpinDoctor.save_tetgen-Tuple{Any, Any}"><code>SpinDoctor.save_tetgen</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">save_tetgen(mesh_all, filename)</code></pre><p>Save mesh in the Tetgen output format.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/agdestein/SpinDoctor.jl/blob/5f9f3fc2bf0af9125f6c56fd3d69075b6099e499/src/geometry/save_tetgen.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpinDoctor.shapeder-Tuple{Any}" href="#SpinDoctor.shapeder-Tuple{Any}"><code>SpinDoctor.shapeder</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">shapeder(points)</code></pre><p>Derivative of shape functions with respect to reference coordinates (<code>ξ₁</code>, <code>ξ₂</code>, <code>ξ₃</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/agdestein/SpinDoctor.jl/blob/5f9f3fc2bf0af9125f6c56fd3d69075b6099e499/src/matrix_assembly/assemble_stiffness_matrix.jl#L62-L66">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpinDoctor.solve" href="#SpinDoctor.solve"><code>SpinDoctor.solve</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">solve</code></pre><p>Solve problem.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/agdestein/SpinDoctor.jl/blob/5f9f3fc2bf0af9125f6c56fd3d69075b6099e499/src/problems/solve.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpinDoctor.solve-Tuple{AnalyticalMatrixFormalism, Any}" href="#SpinDoctor.solve-Tuple{AnalyticalMatrixFormalism, Any}"><code>SpinDoctor.solve</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">solve(problem::AnalyticalMatrixFormalism, gradient, volumes = nothing)</code></pre><p>Compute the signal in a multilayered cylinder or sphere using an analytical matrix formalism solution.</p><p>This function is based on the following articles and corresponding code:     [1] D. S. Grebenkov, NMR Survey of Reflected Brownian Motion,         Rev. Mod.Phys. 79, 1077 (2007)     [2] D. S. Grebenkov, Pulsed-gradient spin-echo monitoring of restricted diffusion in         multilayered structures, J. Magn. Reson. 205, 181-195 (2010).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/agdestein/SpinDoctor.jl/blob/5f9f3fc2bf0af9125f6c56fd3d69075b6099e499/src/analytical/solve_analytical_matrix_formaliism.jl#L1-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpinDoctor.solve-Tuple{HADC, ScalarGradient}" href="#SpinDoctor.solve-Tuple{HADC, ScalarGradient}"><code>SpinDoctor.solve</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">solve_hadc(problem::HADC, gradient::ScalarGradient)</code></pre><p>Compute the ADC using a homogenized ADC model (HADC). This is currently only implemented for scalar gradients.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/agdestein/SpinDoctor.jl/blob/5f9f3fc2bf0af9125f6c56fd3d69075b6099e499/src/adc/solve_hadc.jl#L1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpinDoctor.solve-Tuple{Karger, ScalarGradient}" href="#SpinDoctor.solve-Tuple{Karger, ScalarGradient}"><code>SpinDoctor.solve</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">solve(problem::Karger, gradient)</code></pre><p>Solve the finite pulse Karger model (FPK) using precomputed effective diffusion tensors <code>difftensors</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/agdestein/SpinDoctor.jl/blob/5f9f3fc2bf0af9125f6c56fd3d69075b6099e499/src/btpde/solve_karger.jl#L1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpinDoctor.solve-Tuple{Laplace}" href="#SpinDoctor.solve-Tuple{Laplace}"><code>SpinDoctor.solve</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">solve(laplace::Laplace)</code></pre><p>Compute the Laplace eigenvalues, eigenfunctions and first order moments of products of pairs of eigenfunctions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/agdestein/SpinDoctor.jl/blob/5f9f3fc2bf0af9125f6c56fd3d69075b6099e499/src/matrix_formalism/solve_laplace.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpinDoctor.solve-Tuple{MatrixFormalism, Any}" href="#SpinDoctor.solve-Tuple{MatrixFormalism, Any}"><code>SpinDoctor.solve</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">solve(problem::MatrixFormalism, matrices, lap_eig, gradient)</code></pre><p>Solve for magnetization using Matrix Formalism.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/agdestein/SpinDoctor.jl/blob/5f9f3fc2bf0af9125f6c56fd3d69075b6099e499/src/matrix_formalism/solve_mf.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpinDoctor.solve-Union{Tuple{T}, Tuple{GeneralBTPDE{T}, Any}} where T" href="#SpinDoctor.solve-Union{Tuple{T}, Tuple{GeneralBTPDE{T}, Any}} where T"><code>SpinDoctor.solve</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">solve(problem::GeneralBTPDE, gradient[; callbacks])</code></pre><p>Solve the Bloch-Torrey partial differential equation using P1 finite elements.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/agdestein/SpinDoctor.jl/blob/5f9f3fc2bf0af9125f6c56fd3d69075b6099e499/src/btpde/solve_btpde.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpinDoctor.solve-Union{Tuple{T}, Tuple{IntervalConstanBTPDE{T}, ScalarGradient}} where T" href="#SpinDoctor.solve-Union{Tuple{T}, Tuple{IntervalConstanBTPDE{T}, ScalarGradient}} where T"><code>SpinDoctor.solve</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">run(problem::IntervalConstanBTPDE, gradient)</code></pre><p>Solve the Bloch-Torrey partial differential equation using P1 finite elements. This function uses a manual time stepping scheme (theta-rule), that requires a degree of implicitness <code>θ</code> and a time step <code>Δt</code>.     <code>θ = 0.5</code>: Crank-Nicolson (second order)     <code>θ = 1.0</code>: Implicit Euler (first order)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/agdestein/SpinDoctor.jl/blob/5f9f3fc2bf0af9125f6c56fd3d69075b6099e499/src/btpde/solve_btpde_midpoint.jl#L1-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpinDoctor.solve_multigrad-Tuple{Any, Any}" href="#SpinDoctor.solve_multigrad-Tuple{Any, Any}"><code>SpinDoctor.solve_multigrad</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">solve_multigrad(problem, gradients)</code></pre><p>Solve <code>problem</code> for multiple magnetic field gradients.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/agdestein/SpinDoctor.jl/blob/5f9f3fc2bf0af9125f6c56fd3d69075b6099e499/src/problems/solve_multigrad.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpinDoctor.split_field-Tuple{Any, Any}" href="#SpinDoctor.split_field-Tuple{Any, Any}"><code>SpinDoctor.split_field</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">split_field(mesh, ξ)</code></pre><p>Split the field <code>ξ</code> into a vector containing a <code>view</code> of each compartment. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/agdestein/SpinDoctor.jl/blob/5f9f3fc2bf0af9125f6c56fd3d69075b6099e499/src/geometry/split_field.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpinDoctor.unitcircle-Tuple{Any}" href="#SpinDoctor.unitcircle-Tuple{Any}"><code>SpinDoctor.unitcircle</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">unitcircle(ndirection; half = false, normal = [0, 0, 1])</code></pre><p>Create <code>ndirection</code> directions unformly distributed on the unit circle defined by <code>normal</code>.</p><p>If <code>half</code> is <code>true</code>, the directions lie on a half-circle instead of the whole circle. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/agdestein/SpinDoctor.jl/blob/5f9f3fc2bf0af9125f6c56fd3d69075b6099e499/src/utils/unitcircle.jl#L1-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpinDoctor.unitsphere-Tuple{Any}" href="#SpinDoctor.unitsphere-Tuple{Any}"><code>SpinDoctor.unitsphere</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">unitsphere(ndirection; half = false, normal = [0, 0, 1])</code></pre><p>Create <code>ndirection</code> directions unformly distributed on the unit sphere.</p><p>If <code>half</code> is <code>true</code>, the points will be discributed on the hemisphere defined by <code>normal</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/agdestein/SpinDoctor.jl/blob/5f9f3fc2bf0af9125f6c56fd3d69075b6099e499/src/utils/unitsphere.jl#L1-L7">source</a></section></article></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.10 on <span class="colophon-date" title="Wednesday 29 December 2021 10:00">Wednesday 29 December 2021</span>. Using Julia version 1.7.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
