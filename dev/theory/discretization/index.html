<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Discretization · SpinDoctor.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link rel="canonical" href="https://spindoctormri.github.io/SpinDoctor.jl/theory/discretization/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.svg" alt="SpinDoctor.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">SpinDoctor.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../getting_started/">Getting Started</a></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../../generated/solve_btpde/">Solve BTPDE</a></li><li><a class="tocitem" href="../../generated/custom_gradients/">Custom gradients</a></li><li><a class="tocitem" href="../../generated/compare_adcs/">Compare ADCs</a></li><li><a class="tocitem" href="../../generated/matrix_formalism/">Matrix Formalism</a></li><li><a class="tocitem" href="../../generated/hardi/">High Angular Resolution</a></li></ul></li><li><span class="tocitem">Theory</span><ul><li><a class="tocitem" href="../theory/">Theory</a></li><li><a class="tocitem" href="../btpde/">Bloch-Torrey PDE</a></li><li><a class="tocitem" href="../adc/">Apparent Diffusion Coefficient</a></li><li><a class="tocitem" href="../matrix_formalism/">Matrix Formalism</a></li><li class="is-active"><a class="tocitem" href>Discretization</a><ul class="internal"><li><a class="tocitem" href="#Finite-element-solution-to-the-Bloch-Torrey-PDE"><span>Finite element solution to the Bloch-Torrey PDE</span></a></li><li><a class="tocitem" href="#Finite-element-solution-to-the-HADC-model"><span>Finite element solution to the HADC model</span></a></li><li><a class="tocitem" href="#Finite-element-Matrix-Formalism-signal-representation"><span>Finite element Matrix Formalism signal representation</span></a></li></ul></li></ul></li><li><a class="tocitem" href="../../neurons/">Neurons</a></li><li><a class="tocitem" href="../../api/">API Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Theory</a></li><li class="is-active"><a href>Discretization</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Discretization</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/SpinDoctorMRI/SpinDoctor.jl/blob/master/docs/src/theory/discretization.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Finite-element-discretization"><a class="docs-heading-anchor" href="#Finite-element-discretization">Finite element discretization</a><a id="Finite-element-discretization-1"></a><a class="docs-heading-anchor-permalink" href="#Finite-element-discretization" title="Permalink"></a></h1><p>In SpinDoctor, the finite element mesh generation is performed using an external package called Tetgen. Each finite element mesh consists of</p><ul><li>a list of <span>$N_\text{node}$</span> nodes in three dimensions: <span>$(\mathbf{q}_1, \dots, \mathbf{q}_{N_\text{node}}) = (\mathbf{q}^x, \mathbf{q}^y, \mathbf{q}^z)^\mathsf{T} \in \R^{3 \times N_\text{node}}$</span>;</li><li>a list of <span>$N_\text{element}$</span> tetrahedral elements (<span>$4 \times N_\text{element}$</span> indices referencing the nodes).</li></ul><p>The list of nodes includes double nodes that are placed at the interfaces between compartments connected by permeable membranes. This allows for representing discontinuous magnetization fields <span>$M_i$</span> and <span>$M_j$</span> (or <span>$\phi^i$</span> and <span>$\phi^j$</span>) on the same boundary <span>$\Gamma_{i j}$</span>. To distinguish between the different compartments, let <span>$\{1, \dots, N_\text{node}\} = \bigcup_{i = 1}^{N_\text{cmpt}} \mathcal{I}_i$</span> with <span>$\mathcal{I}_i \cap \mathcal{I}_j = \emptyset$</span> for <span>$i \neq j$</span>. The set <span>$\mathcal{I}_i$</span> contains the indices of the nodes representing compartment <span>$\Omega_i$</span>, including interface nodes.  In the adjacent compartments, the corresponding interface nodes will have different indices, distinct from <span>$\mathcal{I}_i$</span>.</p><p>In SpinDoctor, the finite element space is the space of compartment-wise continuous piecewise linear functions on tetrahedral elements in three dimensions. This space has a set of basis functions whose number is exactly the number of finite element nodes (including double nodes), and that are defined on the entire domain <span>$\Omega$</span>:</p><p class="math-container">\[\varphi_k : \Omega \to [0, 1], \quad k \in \{1, \dots, N_\text{node}\}.\]</p><p>Let the finite element nodes be denoted by <span>$\mathbf{q}_1, \dots, \mathbf{q}_{N_\text{node}}$</span>. The basis function <span>$\varphi_k$</span>, <span>$k \in \mathcal{I}_i$</span>, is a piece-wise linear function, non-zero on the tetrahedra of <span>$\Omega_i$</span> that touch the node <span>$\mathbf{q}_k$</span>, and zero on all other tetrahedra (including tetrahedra of other compartments different than <span>$\Omega_i$</span> that do touch <span>$\mathbf{q}_k$</span>). At the interface <span>$\Gamma_{i j}$</span> between two compartments, the value of <span>$\varphi_k$</span> is set to be the value it has inside its own compartment, distinct from that of the adjacent compartment. On a tetrahedron of <span>$\Omega_i$</span> that touches <span>$\mathbf{q}_k$</span>, <span>$\varphi_k$</span> is equal to <span>$1$</span> on <span>$\mathbf{q}_k$</span> and it is equal to <span>$0$</span> on the other 3 vertices of the tetrahedron. This completely describes the piece-wise linear function. The index sets may then be defined by <span>$\mathcal{I}_i = \{k = 1, \dots, N_\text{node} \ | \ \operatorname{supp} (\varphi_k) \subset \Omega_i\}$</span>, the set of indices of the finite element nodal functions whose supports lie entirely within <span>$\Omega_i$</span>.</p><p>Any function <span>$u$</span> in the finite element space can be written as a linear combination of the above basis functions:</p><p class="math-container">\[u(\vec{x}) = \sum_{k = 1}^{N_\text{node}} \alpha_k \varphi_k(\vec{x}) =
\bm{\alpha}^\mathsf{T} \bm{\varphi}(\vec{x}), \]</p><p>where <span>$\bm{\alpha} = (\alpha_1, \dots, \alpha_{N_\text{node}})^\mathsf{T}$</span> is the vector of coefficients and <span>$\bm{\varphi} = (\varphi_1, \dots, \varphi_{N_\text{node}})^\mathsf{T}$</span> is the vector of finite element nodal basis functions.</p><p>To discretize the Bloch-Torrey and Laplace operators, we construct the following finite element matrices: <span>$\mathbf{M},\mathbf{S},\mathbf{Q}\in\R^{N_\text{node}\times N_\text{node}}$</span>, known in the FEM literature as the mass, stiffness, and flux matrices, respectively. These matrices matrices we need are defined as follows, for <span>$(k, l) \in \{1, \dots, N_\text{node}\}$</span>:</p><p class="math-container">\[M_{kl} = \int_\Omega \varphi_k(\vec{x}) \varphi_l(\vec{x}) \, \mathrm{d}
\Omega(\vec{x}),\]</p><p class="math-container">\[S_{kl} = \int_\Omega \mathbf{D}(\vec{x}) \nabla \varphi_k(\vec{x}) \cdot \nabla
\varphi_l(\vec{x}) \, \mathrm{d} \Omega(\vec{x}),\]</p><p class="math-container">\[Q_{kl} = \sum_{i = 1}^{N_\text{cmpt}} Q_{kl}^i + \sum_{i = 1}^{N_\text{cmpt}} \sum_{j =
1}^{N_\text{cmpt}} Q_{kl}^{i j},\]</p><p>the latter being defined as the sum of interface integrals:</p><p class="math-container">\[Q_{kl}^i = \kappa_i \int_{\Gamma_i} \varphi_k(\vec{x}) \varphi_l(\vec{x}) \, \mathrm{d}
\Gamma(\vec{x}), \quad i \in \{1, \dots, N_\text{cmpt}\},\]</p><p class="math-container">\[Q_{kl}^{i j} =
\begin{cases}
    \kappa_{i j} c_{j i} \int_{\Gamma_{i j}} \varphi_k(\vec{x}) \varphi_l(\vec{x}) \,
    \mathrm{d} \Gamma(\vec{x}), \quad  &amp; (k, l) \in \mathcal{I}_i^2, \\
    -\kappa_{i j} c_{i j} \int_{\Gamma_{i j}} \varphi_k(\vec{x}) \varphi_l(\vec{x}) \,
    \mathrm{d} \Gamma(\vec{x}), \quad &amp; (k, l) \in \mathcal{I}_i \times \mathcal{I}_j, \\
    0, \quad &amp; \text{otherwise}.
\end{cases}
\quad (i, j) \in \{1, \dots, N_\text{cmpt}\}^2.\]</p><p>We remind the reader that <span>$i$</span> and <span>$j$</span> are compartment indices, while <span>$k$</span> and <span>$l$</span> are finite element nodal indices. Note that the above sum formulation counts each interface twice, but only considers the contribution to one side of the boundary at the time. It also correctly accounts for corner nodes (if any) that belong to two different permeable boundaries at the same time.</p><p>The weak form of the Bloch-Torrey PDE also requires computing the first order moments of the product of pairs of finite element basis functions. We let these three matrices be denoted by <span>$\mathbf{J}^x$</span>, <span>$\mathbf{J}^y$</span> and <span>$\mathbf{J}^z$</span>:</p><p class="math-container">\[J_{k l}^x = \int_\Omega x \, \varphi_k(\vec{x}) \varphi_l(\vec{x}) \, \mathrm{d}
\Omega(\vec{x}), \quad (k, l) \in \{1, \dots, N_\text{node}\}^2,\]</p><p class="math-container">\[J_{k l}^y = \int_\Omega y \, \varphi_k(\vec{x}) \varphi_l(\vec{x}) \, \mathrm{d}
\Omega(\vec{x}), \quad (k, l) \in \{1, \dots, N_\text{node}\}^2,\]</p><p class="math-container">\[J_{k l}^z = \int_\Omega z \, \varphi_k(\vec{x}) \varphi_l(\vec{x}) \, \mathrm{d}
\Omega(\vec{x}), \quad (k, l) \in \{1, \dots, N_\text{node}\}^2.\]</p><p>where <span>$\vec{x} = (x, y, z)^\mathsf{T}$</span>. For a given gradient vector <span>$\vec{g} = (g_x, g_y, g_z)^\mathsf{T}$</span>, we define</p><p class="math-container">\[\mathbf{J}(\vec{g}) = g_x \mathbf{J}^x + g_y \mathbf{J}^y + g_z \mathbf{J}^z.\]</p><p>In addition, we define the finite element relaxation matrix <span>$\mathbf{R} \in \mathbb{R}^{N_\text{node} \times N_\text{node}}$</span> given by</p><p class="math-container">\[R_{kl} = \int_\Omega \frac{1}{T_2(\vec{x})} \, \varphi_k(\vec{x}) \varphi_l(\vec{x}) \,
\mathrm{d} \Omega(\vec{x}), \quad (k, l) \in \{1, \dots, N_\text{node}\}^2.\]</p><p>In SpinDoctor, these matrices are assembled from local element matrices and the assembly process is based on vectorized routines of, which replace expensive loops over elements by operations with 3-dimensional arrays. All local element matrices in the assembly of <span>$\mathbf{S}$</span>, <span>$\mathbf{M}$</span>, and <span>$\mathbf{Q}$</span> are evaluated at the same time and stored in a full matrix of size <span>$4 \times 4 \times N_\text{element}$</span>, where <span>$N_\text{element}$</span> denotes the number of tetrahedral elements.</p><p>The matrices <span>$\mathbf{J}^x$</span>, <span>$\mathbf{J}^y$</span>, and <span>$\mathbf{J}^z$</span> are assembled as coordinate weighted mass matrices, where the three coordinate functions <span>$\vec{x} \mapsto x$</span>, <span>$y$</span>, <span>$z$</span> act as nodal weights in the assembly process, given by <span>$\mathbf{q}^x$</span>, <span>$\mathbf{q}^y$</span>, <span>$\mathbf{q}^z$</span>; the vectors of <span>$x$</span>, <span>$y$</span>, and <span>$z$</span> coordinates of the finite element nodes.</p><p>With compartment-wise constant <span>$T_2$</span>-relaxation times, <span>$\mathbf{R}$</span> is a block-diagonally scaled version of the mass matrix <span>$\mathbf{M}$</span>, where the weights are the inverses of the relaxation times.</p><h2 id="Finite-element-solution-to-the-Bloch-Torrey-PDE"><a class="docs-heading-anchor" href="#Finite-element-solution-to-the-Bloch-Torrey-PDE">Finite element solution to the Bloch-Torrey PDE</a><a id="Finite-element-solution-to-the-Bloch-Torrey-PDE-1"></a><a class="docs-heading-anchor-permalink" href="#Finite-element-solution-to-the-Bloch-Torrey-PDE" title="Permalink"></a></h2><p>The solution to the Bloch-Torrey partial differential equation may be projected onto the finite element nodal basis <span>$(\varphi_k)_{1 \leq k \leq N_\text{node}}$</span>, in which case it is given by</p><p class="math-container">\[M(\vec{x},t) = \sum_{k = 1}^{N_\text{node}}
\xi_k(t)\varphi_k(\vec{x}) = \bm{\xi}^\mathsf{T}\!(t) \bm{\varphi}(\vec{x}),\]</p><p>where <span>$\bm{\varphi} = (\varphi_1,\dots,\varphi_{N_\text{node}})^\mathsf{T} \in \mathbb{R}^{N_\text{node}}$</span> is the vector of finite element basis functions and the function <span>$\bm{\xi} = (\xi_1, \dots, \xi_{N_\text{node}})^\mathsf{T} : [0, T_\text{echo}] \to \mathbb{C}^{N_\text{node}}$</span> is the solution to the following system of <em>ordinary</em> differential equations (ODE):</p><p class="math-container">\[\mathbf{M} \frac{\mathrm{d} \bm{\xi}}{\mathrm{d} t} = -\left(\mathbf{S} + \mathbf{Q} + \mathbf{R} +
\underline{\mathrm{i}} \gamma \mathbf{J}(\vec{g}(t)) \right) \bm{\xi}(t).\]</p><h2 id="Finite-element-solution-to-the-HADC-model"><a class="docs-heading-anchor" href="#Finite-element-solution-to-the-HADC-model">Finite element solution to the HADC model</a><a id="Finite-element-solution-to-the-HADC-model-1"></a><a class="docs-heading-anchor-permalink" href="#Finite-element-solution-to-the-HADC-model" title="Permalink"></a></h2><p>Similarly, given an isolated compartment <span>$\Omega$</span> and a scalar gradient <span>$\vec{g}(t) = f(t) g \vec{d}$</span>, the solution to the HADC model, <span>$\omega$</span>, may be obtained by solving the equation</p><p class="math-container">\[\mathbf{M} \frac{\mathrm{d} \bm{\zeta}}{\mathrm{d} t} = - \mathbf{S} \bm{\zeta}(t) + F(t)
\mathbf{G} \mathbf{D} \vec{d},\]</p><p>where <span>$F(t) = \int_0^t f(t) \, \mathrm{d} t$</span>, <span>$\bm{\zeta} = (\zeta_1, \dots, \zeta_{N_\text{node}}) : [0, T_\text{echo}] \to \mathbb{R}^{N_\text{node}}$</span> is the unknown vector of coefficients of the solution <span>$\omega(\vec{x}, t) = \bm{\zeta}^\mathsf{T}(t) \bm{\varphi}(\vec{x})$</span>, <span>$\bm{\varphi} = (\varphi_1, \dots, \varphi_{N_\text{node}})$</span> is the vector of finite element basis functions, and <span>$\mathbf{G} \in \mathbb{R}^{N_\text{node} \times 3}$</span> is given by</p><p class="math-container">\[\mathbf{G} = \sum_{k = 1}^{N_\text{node}} \int_{\partial \Omega} \varphi_k(\vec{x})
\bm{\varphi}(\vec{x}) \vec{n}^\mathsf{T}\!(\vec{x}) \, \mathrm{d}\Gamma(\vec{x}),\]</p><p>where <span>$\vec{n} = (n_x, n_y, n_z)^\mathsf{T}$</span> is the outwards unit normal. This three-column matrix represents the components of the boundary integral of the quantity <span>$F(t) \vec{d}^\mathsf{T} \mathbf{D} \vec{n}$</span>, where the constant diffusivity and gradient sequence dependent part <span>$F(t) \vec{d}^\mathsf{T} \mathbf{D}$</span> has been factored out. They can thus be assembled independently of the gradient sequence, and be reused when solving for multiple sequences or directions. They are assembled using the same routine as for <span>$\mathbf{Q}$</span>.</p><p>The boundary integral <span>$h$</span> is then given by</p><p class="math-container">\[h(t) = \frac{1}{|\Omega|} \bm{\zeta}^\mathsf{T}\!(t) \mathbf{G} \vec{d},\]</p><p>where <span>$|\Omega| = \sum_{j,k = 1}^{N_\text{node}} M_{jk}$</span> is computed using the mass matrix.</p><h2 id="Finite-element-Matrix-Formalism-signal-representation"><a class="docs-heading-anchor" href="#Finite-element-Matrix-Formalism-signal-representation">Finite element Matrix Formalism signal representation</a><a id="Finite-element-Matrix-Formalism-signal-representation-1"></a><a class="docs-heading-anchor-permalink" href="#Finite-element-Matrix-Formalism-signal-representation" title="Permalink"></a></h2><p>Both of the above ODEs are of dimension <span>$N_\text{node}$</span>, the number of finite element nodes. The finite element discretized Matrix Formalism representation uses a different approach, limiting the problem size to <span>$N_\text{eig}$</span>, the number of Laplace eigenfunctions (of which the choice is further explored in section. But first we need to solve an eigenvalue problem involving matrices of size <span>$N_\text{node}\times N_\text{node}$</span>. The finite element discretization changes the continuous Laplace operator eigenvalue problem into the following discrete, generalized <em>matrix</em> eigenvalue problem: find <span>$(\lambda, \mathbf{p}) \in \mathbb{R} \times \mathbb{R}^{N_\text{node}}$</span> such that</p><p class="math-container">\[\lambda \mathbf{M} \mathbf{p} = (\mathbf{S} + \mathbf{Q}) \mathbf{p},\]</p><p>of which we will retain the <span>$N_\text{eig}$</span> smallest eigenvalues and corresponding eigenvectors <span>$\{(\lambda_n, \mathbf{p}_n)\}_{1 \leq n \leq N_\text{eig}}$</span>, with <span>$N_\text{eig} \leq N_\text{node}$</span>. Note however that there are in total <span>$N_\text{node}$</span> solutions to the problem. Moving back to the space of functions (the function space <span>$P_1$</span>), the eigenfunction <span>$\phi_n(\vec{x})$</span> associated to the eigenvalue <span>$\lambda_n$</span> is then</p><p class="math-container">\[\phi_n(\vec{x}) = \sum_{k = 1}^{N_\text{node}} p_n^k \varphi_k(\vec{x}) =
\mathbf{p}_n^\mathsf{T} \bm{\varphi}(\vec{x}), \quad n \in \{1, \dots, N_\text{eig}\},\]</p><p>where the entries of the eigenvector <span>$\mathbf{p}_n$</span> are the coefficients of the eigenfunction <span>$\phi_n$</span> in the finite element basis. Using matrix notation, this conversion can also be written <span>$\bm{\phi} = \mathbf{P}^\mathsf{T} \bm{\varphi}$</span>, where <span>$\bm{\varphi} = (\varphi_1, \dots, \varphi_{N_\text{node}})^\mathsf{T}$</span>, <span>$\bm{\phi} = (\phi_1, \dots, \phi_{N_\text{eig}})^\mathsf{T}$</span>, and <span>$\mathbf{P} = (\mathbf{p}_1, \dots, \mathbf{p}_{N_\text{eig}}) \in \mathbb{R}^{N_\text{node} \times N_\text{eig}}$</span>. The integrals of the finite element discretized eigenfunctions are then given by <span>$\bm{\Phi} = \int_\Omega \bm{\phi}(\vec{x}) \, \mathrm{d} \Omega(\vec{x}) = \mathbf{P}^\mathsf{T} \mathbf{M} \mathbf{o}$</span>, where <span>$\mathbf{o} = (1, \dots, 1)^\mathsf{T} \in \mathbb{R}^{N_\text{node}}$</span>. Similarly, the coefficients of the initial spin density in the finite element discretized eigenfunction basis are given by <span>$\bm{\nu} = \int_\Omega \rho(\vec{x}) \bm{\phi}(\vec{x}) \, \mathrm{d} \Omega(\vec{x}) = \mathbf{P}^\mathsf{T} \mathbf{M} \bm{\rho}$</span>, where <span>$\bm{\rho} = (\rho_{i(k)})_{1 \leq k \leq N_\text{node}} \in \mathbb{R}^{N_\text{node}}$</span> and <span>$i(k) \in \{1, \dots, N_\text{cmpt}\}$</span> is such that <span>$k \in \mathcal{I}_{i(k)}$</span>.</p><p>Then it is clear that the first order moments of the product of pairs of Laplace eigenfunctions can be written as:</p><p class="math-container">\[\mathbf{A}^u = \mathbf{P}^\mathsf{T}\mathbf{J}^u\mathbf{P}, \quad u = x, y, z.\]</p><p>These three matrices are computed using a total of six matrix-matrix multiplications. Similarly, the eigenfunction basis relaxation matrix \mathbf{T} may be obtained from the finite element nodal basis relaxation matrix \mathbf{R} by</p><p class="math-container">\[\mathbf{T} = \mathbf{P}^\mathsf{T} \mathbf{R} \mathbf{P}.\]</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../matrix_formalism/">« Matrix Formalism</a><a class="docs-footer-nextpage" href="../../neurons/">Neurons »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.15 on <span class="colophon-date" title="Saturday 19 March 2022 11:11">Saturday 19 March 2022</span>. Using Julia version 1.7.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
