<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Compare ADCs · SpinDoctor.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link rel="canonical" href="https://agdestein.github.io/SpinDoctor.jl/examples/compute_adc/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.svg" alt="SpinDoctor.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">SpinDoctor.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../getting_started/">Getting Started</a></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../solve_btpde/">Solve BTPDE</a></li><li><a class="tocitem" href="../custom_gradient/">Custom gradients</a></li><li class="is-active"><a class="tocitem" href>Compare ADCs</a><ul class="internal"><li><a class="tocitem" href="#Building-a-biological-model"><span>Building a biological model</span></a></li><li><a class="tocitem" href="#Computing-the-ADC-using-different-methods"><span>Computing the ADC using different methods</span></a></li><li><a class="tocitem" href="#Comparing-results"><span>Comparing results</span></a></li></ul></li><li><a class="tocitem" href="../hardi/">High Angular Resolution</a></li></ul></li><li><span class="tocitem">Theory</span><ul><li><a class="tocitem" href="../../theory/definitions/">Definitions</a></li><li><a class="tocitem" href="../../theory/btpde/">Bloch-Torrey PDE</a></li><li><a class="tocitem" href="../../theory/adc/">Apparent Diffusion Coefficient</a></li><li><a class="tocitem" href="../../theory/matrix_formalism/">Matrix Formalism</a></li><li><a class="tocitem" href="../../theory/discretization/">Discretization</a></li></ul></li><li><a class="tocitem" href="../../neurons/">Neurons</a></li><li><a class="tocitem" href="../../api/">API Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Examples</a></li><li class="is-active"><a href>Compare ADCs</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Compare ADCs</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/agdestein/SpinDoctor.jl/blob/master/docs/src/examples/compute_adc.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Compare-ADCs"><a class="docs-heading-anchor" href="#Compare-ADCs">Compare ADCs</a><a id="Compare-ADCs-1"></a><a class="docs-heading-anchor-permalink" href="#Compare-ADCs" title="Permalink"></a></h1><p>The <a href="examples/@ref ADC">apparent diffusion coefficient</a> (ADC) may be sufficient to describe the signal attenuation for small <span>$b$</span>-values. SpinDoctor comes with multiple approaches for computing or estimating the ADC for a <code>ScalarGradient</code> <span>$\vec{g}(t) = f(t) g \vec{d}$</span>:</p><ul><li>Using the free diffusion coefficient <span>$\vec{d}^\mathsf{T} \mathbf{D} \vec{d}$</span>, which represents unrestricted diffusion in the absence of boundaries;</li><li>Computing the short diffusion time approximation for the ADC</li><li>Fitting the log-signal obtained by solving the BTPDE for different <span>$b$</span>-values</li><li>Solving a homogenized model (HADC) assuming negligible permeability</li><li>Using the matrix formalism effective diffusion tensor</li></ul><p>In this example we will compare the different approaches.</p><h2 id="Building-a-biological-model"><a class="docs-heading-anchor" href="#Building-a-biological-model">Building a biological model</a><a id="Building-a-biological-model-1"></a><a class="docs-heading-anchor-permalink" href="#Building-a-biological-model" title="Permalink"></a></h2><p>We start by loading SpinDoctor and a Makie plotting backend.</p><pre><code class="language-julia hljs">using SpinDoctor
using LinearAlgebra
using GLMakie</code></pre><p>Here we create a recipe for five stacked plates with isotropic diffusion tensors. They should allow for free diffusion in the horizontal direction, but a rather restricted vertical diffusion with the permeable membranes.</p><pre><code class="language-julia hljs">ncell = 5</code></pre><pre><code class="language-julia hljs">setup = PlateSetup(;
    name = &quot;Plates&quot;,
    width = 50.0,
    depth = 50.0,
    heights = fill(5.0, ncell),
    bend = 0.0,
    twist = 0.0,
    refinement = 10.0,
)</code></pre><pre><code class="language-julia hljs">coeffs = coefficients(
    setup;
    D = [0.002 * I(3) for _ = 1:ncell],
    T₂ = fill(Inf, ncell),
    ρ = fill(1.0, ncell),
    κ = (; interfaces = fill(1e-4, ncell - 1), boundaries = fill(0.0, ncell)),
    γ = 2.67513e-4,
)</code></pre><p>We then proceed to assemble the biological model and the associated finite element matrices.</p><pre><code class="language-julia hljs">mesh, = create_geometry(setup; recreate = true)
model = Model(; mesh, coeffs...)
matrices = assemble_matrices(model);</code></pre><p>We may also compute some useful quantities, including a scalar diffusion coefficient from the diffusion tensors.</p><pre><code class="language-julia hljs">volumes = get_cmpt_volumes(model.mesh)
D_avg = 1 / 3 * tr.(model.D)&#39; * volumes / sum(volumes)
ncompartment = length(model.mesh.points)</code></pre><p>The gradient pulse sequence will be a PGSE with both vertical and horizontal components. This allows for both restricted vertical diffusion and almost unrestricted horizontal diffusion. The different approaches should hopefully confirm this behaviour.</p><pre><code class="language-julia hljs">dir = [1.0, 0.0, 1.0]
profile = PGSE(2500.0, 4000.0)
b = 1000
g = √(b / int_F²(profile)) / model.γ
gradient = ScalarGradient(dir, profile, g)</code></pre><h2 id="Computing-the-ADC-using-different-methods"><a class="docs-heading-anchor" href="#Computing-the-ADC-using-different-methods">Computing the ADC using different methods</a><a id="Computing-the-ADC-using-different-methods-1"></a><a class="docs-heading-anchor-permalink" href="#Computing-the-ADC-using-different-methods" title="Permalink"></a></h2><h3 id="Short-term-approximation"><a class="docs-heading-anchor" href="#Short-term-approximation">Short term approximation</a><a id="Short-term-approximation-1"></a><a class="docs-heading-anchor-permalink" href="#Short-term-approximation" title="Permalink"></a></h3><p>A simple model for the ADC is given by the <a href="../../theory/adc/#STA">short term approximation</a>.</p><pre><code class="language-julia hljs">adc_sta_cmpts = compute_adc_sta(model, gradient)
adc_sta = volumes&#39;adc_sta_cmpts / sum(volumes)</code></pre><h3 id="Fitting-the-ADC"><a class="docs-heading-anchor" href="#Fitting-the-ADC">Fitting the ADC</a><a id="Fitting-the-ADC-1"></a><a class="docs-heading-anchor-permalink" href="#Fitting-the-ADC" title="Permalink"></a></h3><p>A more robust approach is to directly fit the BTPDE signal to a series of b-values. This is however more computationally expensive. We start by building a set of gradients.</p><pre><code class="language-julia hljs">bvalues = 0:400:4000
gvalues = map(b -&gt; √(b / int_F²(profile)) / coeffs.γ, bvalues)
gradients = [ScalarGradient(gradient.dir, gradient.profile, g) for g ∈ gvalues]</code></pre><p>The <a href="../../api/#SpinDoctor.solve_multigrad"><code>solve_multigrad</code></a> function computes the magnetization for each gradient.</p><pre><code class="language-julia hljs">btpde = IntervalConstanBTPDE(; model, matrices, θ = 0.5, timestep = 5)
ξ, = solve_multigrad(btpde, gradients)</code></pre><p>The signals can be computed from the magnetization fields.</p><pre><code class="language-julia hljs">signals = [compute_signal(matrices.M, ξ) for ξ ∈ ξ]
signals_cmpts = [compute_signal.(matrices.M_cmpts, split_field(model.mesh, ξ)) for ξ ∈ ξ]</code></pre><p>Fitting the ADC is straightforward.</p><pre><code class="language-julia hljs">adc_fit = fit_adc(bvalues, signals)
adc_fit_cmpts =
    [fit_adc(bvalues, [s[icmpt] for s ∈ signals_cmpts]) for icmpt = 1:ncompartment]</code></pre><h3 id="Homogenized-ADC-model"><a class="docs-heading-anchor" href="#Homogenized-ADC-model">Homogenized ADC model</a><a id="Homogenized-ADC-model-1"></a><a class="docs-heading-anchor-permalink" href="#Homogenized-ADC-model" title="Permalink"></a></h3><p>The <a href="../../theory/adc/#HADC">HADC</a>-model uses homogenization and assumes negligible permeability between the compartments. This does require solving an ODE involving all the degrees of freedom.</p><pre><code class="language-julia hljs">hadc = HADC(; model, matrices, reltol = 1e-4, abstol = 1e-6)
adc_homogenized_cmpts = solve(hadc, gradient)
adc_homogenized = volumes&#39;adc_homogenized_cmpts / sum(volumes)</code></pre><h3 id="Matrix-Formalism"><a class="docs-heading-anchor" href="#Matrix-Formalism">Matrix Formalism</a><a id="Matrix-Formalism-1"></a><a class="docs-heading-anchor-permalink" href="#Matrix-Formalism" title="Permalink"></a></h3><p>If a Laplace eigendecomposition is available, the HADC can be approximated with little additional computational expense.</p><pre><code class="language-julia hljs">laplace = Laplace(; model, matrices, neig_max = 400)
lap_eig = solve(laplace)</code></pre><p>An effective diffusion tensor can be computed.</p><pre><code class="language-julia hljs">D_mf = compute_mf_diffusion_tensor(model.mesh, matrices.M, lap_eig, gradient)</code></pre><pre><code class="nohighlight hljs">3×3 Matrix{Float64}:
  0.00180812  -4.99349e-8  -1.10896e-8
 -4.99349e-8   0.00180823   1.02731e-8
 -1.10896e-8   1.02731e-8   0.000326084</code></pre><p>We observe that <span>$D_{x x}$</span> and <span>$D_{y y}$</span> are very close to the intrinsic diffusion coefficient, <span>$D = 0.002$</span>, which confirms that diffusion in the horizontal direction is almost unrestricted. <span>$D_{z z}$</span> is significantly smaller, confirming the presence of membranes along the vertical direction.</p><p>In particular, we may deduce the MF-ADC in our direction.</p><pre><code class="language-julia hljs">adc_mf = dir&#39;D_mf * dir / dir&#39;dir</code></pre><h2 id="Comparing-results"><a class="docs-heading-anchor" href="#Comparing-results">Comparing results</a><a id="Comparing-results-1"></a><a class="docs-heading-anchor-permalink" href="#Comparing-results" title="Permalink"></a></h2><h3 id="Compartment-ADCs"><a class="docs-heading-anchor" href="#Compartment-ADCs">Compartment ADCs</a><a id="Compartment-ADCs-1"></a><a class="docs-heading-anchor-permalink" href="#Compartment-ADCs" title="Permalink"></a></h3><p>Here we make a comparison between the compartment ADCs. For MF, only a global ADC was computed.</p><pre><code class="language-julia hljs">n = ncompartment
fig = Figure()
ax = Axis(fig[1, 1];
    xticks = (1:4, [&quot;STA&quot;, &quot;Fit BTPDE&quot;, &quot;HADC&quot;, &quot;MF&quot;]),
    ylabel = &quot;ADC / D&quot;,
    title = &quot;Compartment ADCs&quot;,
)
barplot!(ax, fill(1, n), adc_sta_cmpts ./ D_avg; dodge = 1:n)
barplot!(ax, fill(2, n), adc_fit_cmpts ./ D_avg; dodge = 1:n)
barplot!(ax, fill(3, n), adc_homogenized_cmpts ./ D_avg; dodge = 1:n)
barplot!(ax, [4], [adc_mf / D_avg])</code></pre><p><img src="../../assets/adc_bars.png" alt="ADC Barplot"/></p><p>The STA and HADC are the same for all compartments, as they consider them separately and all the compartments have the same size. The fitted ADC is larger for the three inner compartments, as they all have permeable membranes both below and above, in contrast to the top and bottom compartments that have hard walls.</p><h3 id="Signal-attenuation"><a class="docs-heading-anchor" href="#Signal-attenuation">Signal attenuation</a><a id="Signal-attenuation-1"></a><a class="docs-heading-anchor-permalink" href="#Signal-attenuation" title="Permalink"></a></h3><p>We may also inspect the resulting signal attenuations.</p><pre><code class="language-julia hljs">fig = Figure()
ax = Axis(fig[1,1]; xlabel = &quot;b&quot;, yscale = log10, title = &quot;Signal attenuation&quot;)
lines!(ax, [0, bvalues[end]], [1, exp(-adc_sta * bvalues[end])]; linestyle = :dash, label = &quot;ADC STA&quot;)
lines!(ax, [0, bvalues[end]], [1, exp(-adc_fit * bvalues[end])]; linestyle = :dash, label = &quot;ADC Fit&quot;)
lines!(ax, [0, bvalues[end]], [1, exp(-adc_homogenized * bvalues[end])]; linestyle = :dash, label = &quot;HADC&quot;)
lines!(ax, [0, bvalues[end]], [1, exp(-adc_mf * bvalues[end])]; linestyle = :dash, label = &quot;ADC MF&quot;)
lines!(ax, [0, bvalues[end]], [1, exp(-D_avg * bvalues[end])]; linestyle = :dash, label = &quot;Free diffusion&quot;)
scatterlines!(ax, bvalues, abs.(signals) ./ abs(signals[1]); label = &quot;BTPDE Signal&quot;)
axislegend(ax)</code></pre><p><img src="../../assets/attenuation.png" alt="Signal attenuation"/></p><p>We observe the following:</p><ul><li>The exact signal starts to visually deviate from the log-linear regime after <span>$b = 2000$</span>. For higher <span>$b$</span>-values, the ADC is no longer sufficient to describe the attenuation, as higher order terms can no longer be neglected.</li><li>The fit-ADC signal coincides with the exact signal for the lowest <span>$b$</span>-values. This makes sense since that is how this ADC was obtained to begin with. This is considered to be the &quot;reference&quot; ADC.</li><li>The free diffusion signal attenuates more thant the exact signal by many orders of magnitude, which confirms the presence of restrictive membranes and boundaries in the gradient direction.</li><li>The HADC signal attenuates less than the exact signal, as it assumes a more severe restriction with impermeable membranes.</li><li>The MF-ADC signal coincides with the HADC signal, as the former is simply an MF approximation of the latter.</li></ul></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../custom_gradient/">« Custom gradients</a><a class="docs-footer-nextpage" href="../hardi/">High Angular Resolution »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.10 on <span class="colophon-date" title="Sunday 9 January 2022 22:45">Sunday 9 January 2022</span>. Using Julia version 1.7.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
