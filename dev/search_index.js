var documenterSearchIndex = {"docs":
[{"location":"neurons/#Neuron-recipes","page":"Neurons","title":"Neuron recipes","text":"","category":"section"},{"location":"neurons/","page":"Neurons","title":"Neurons","text":"The diffusion MRI signal arising from neurons can be numerically simulated by solving the Bloch-Torrey partial differential equation. In order to facilitate the diffusion MRI simulation of realistic neurons by the research community, we constructed finite element meshes for a group of 36 pyramidal neurons and a group of 29 spindle neurons whose morphological descriptions were found in the publicly available neuron repository NeuroMopho.org. These finite elements meshes range from having 15163 nodes to 622553 nodes. We also broke the neurons into the soma and dendrite branches and created finite elements meshes for these cell components. Through the Neuron Module, these neuron and components finite element meshes can be seamlessly coupled with the functionalities of SpinDoctor to provide the diffusion MRI signal that can be attributed to spins inside neurons.","category":"page"},{"location":"neurons/","page":"Neurons","title":"Neurons","text":"The neuron mesh files are available at https://github.com/SpinDoctorMRI/NeuronMeshes.","category":"page"},{"location":"neurons/","page":"Neurons","title":"Neurons","text":"The table below lists the names and the finite element mesh sizes of the group of 36 pyramidal neurons and the group of 29 spindle neurons.","category":"page"},{"location":"neurons/","page":"Neurons","title":"Neurons","text":"Neuron ID Num. of FE mesh nodes Neuron ID Num. of FE mesh nodes\n03a_spindle2aFI 38202 02a_pyramidal2aFI 119156\n03a_spindle6aFI 44000 02b_pyramidal1aACC 45216\n03b_spindle4aACC 17370 02b_pyramidal1aFI 105384\n03b_spindle5aACC 26345 03a_pyramidal9aFI 81530\n03b_spindle6aACC 26792 03b_pyramidal2aACC 28183\n03b_spindle7aACC 21618 03b_pyramidal3aACC 27607\n04b_spindle3aFI 51265 03b_pyramidal3aFI 151362\n05b_spindle5aFI 22457 03b_pyramidal4aFI 96177\n06b_spindle8aACC 15163 03b_pyramidal9aFI 66162\n07b_spindle9aACC 54952 04a_pyramidal4aACC 150897\n08a_spindle13aACC 46293 04a_pyramidal5aACC 89256\n09o_spindle7aFI 38992 04b_pyramidal5aFI 95784\n09o_spindle8aFI 60755 04b_pyramidal6aACC 87195\n10a_spindle18aACC 25797 04b_pyramidal6aFI 90482\n12a_spindle19aACC 31841 04b_pyramidal7aACC 622553\n12o_spindle9aFI 29320 05a_pyramidal10aACC 201506\n13o_spindle10aFI 43081 05a_pyramidal8aACC 139975\n15o_spindle12aFI 101548 05b_pyramidal7aFI 208203\n16o_spindle13aFI 18266 05b_pyramidal8aFI 124350\n19o_spindle14aFI 25786 05b_pyramidal9aACC 366659\n21o_spindle15aFI 28822 06a_pyramidal11aACC 319574\n23o_spindle16aFI 30073 06b_pyramidal10aFI 106808\n25o_spindle17aFI 52919 06b_pyramidal12aACC 277718\n26o_spindle18aFI 36239 07a_pyramidal13aACC 155854\n27o_spindle19aFI 50807 07b_pyramidal14aACC 309789\n28o_spindle20aFI 56036 08o_pyramidal11aFI 419651\n28o_spindle21aFI 17581 10a_pyramidal15aACC 56184\n29o_spindle22aFI 18414 11a_pyramidal16aACC 222732\n30o_spindle23aFI 26357 11o_pyramidal12aFI 380293\n22o_pyramidal16aFI 389878 17o_pyramidal13aFI 326989\n24o_pyramidal17aFI 245058 18o_pyramidal14aFI 338453\n25o_pyramidal18aFI 71209 20o_pyramidal15aFI 247116\n31o_pyramidal19aFI 619390  ","category":"page"},{"location":"neurons/","page":"Neurons","title":"Neurons","text":"The following table shows the morphological characteristics for the neurons.","category":"page"},{"location":"neurons/","page":"Neurons","title":"Neurons","text":"Neuron ID Brain region Avg. dia. (mu m) Height (mu m) Soma vol. (mu m^3) Total vol. (mu m^3)\n02a_pyramidal2aFI fronto-insula 1.27 404.85 19701.05 25639.61\n02b_pyramidal1aACC anterior cingulate 1.58 363.08 9065.56 11579.71\n02b_pyramidal1aFI fronto-insula 1.62 381.56 22475.52 29804.96\n03a_pyramidal9aFI fronto-insula 2.15 532.30 22557.27 30189.28\n03a_spindle2aFI fronto-insula 1.74 387.16 13406.27 17684.23\n03a_spindle6aFI fronto-insula 1.66 501.47 33458.19 37812.72\n03b_pyramidal2aACC anterior cingulate 1.48 189.29 2977.21 4487.44\n03b_pyramidal3aACC anterior cingulate 1.14 188.45 6005.06 6891.04\n03b_pyramidal3aFI fronto-insula 1.84 496.35 32510.62 46154.08\n03b_pyramidal4aFI fronto-insula 1.33 414.70 35253.85 39324.87\n03b_pyramidal9aFI fronto-insula 1.92 430.06 15263.14 20532.57\n03b_spindle4aACC anterior cingulate 1.43 336.33 3098.39 4070.19\n03b_spindle5aACC anterior cingulate 1.49 221.52 11925.78 13242.53\n03b_spindle6aACC anterior cingulate 1.33 398.36 4027.74 6058.67\n03b_spindle7aACC anterior cingulate 1.18 369.51 4982.41 6076.52\n04a_pyramidal4aACC anterior cingulate 1.52 705.96 5684.55 13637.33\n04a_pyramidal5aACC anterior cingulate 1.86 410.59 15010.43 24648.35\n04b_pyramidal5aFI fronto-insula 1.78 480.13 10312.87 17184.26\n04b_pyramidal6aACC anterior cingulate 1.41 465.88 3129.97 7497.12\n04b_pyramidal6aFI fronto-insula 1.56 310.21 14718.05 21708.21\n04b_pyramidal7aACC anterior cingulate 1.3 610.42 17060.60 28552.49\n04b_spindle3aFI fronto-insula 2.71 391.14 22569.99 28404.13\n05a_pyramidal10aACC anterior cingulate 1.74 281.20 16604.06 21826.41\n05a_pyramidal8aACC anterior cingulate 1.29 430.37 24709.77 29778.79\n05b_pyramidal7aFI fronto-insula 2.18 281.02 25720.11 32731.05\n05b_pyramidal8aFI fronto-insula 1.66 361.45 32527.06 44679.46\n05b_pyramidal9aACC anterior cingulate 1.56 650.60 23948.05 40014.54\n05b_spindle5aFI fronto-insula 2.35 381.88 15383.08 18190.63\n06a_pyramidal11aACC anterior cingulate 1.46 437.60 17222.02 29995.02\n06b_pyramidal10aFI fronto-insula 1.92 365.18 43127.81 52179.53\n06b_pyramidal12aACC anterior cingulate 1.52 324.94 17181.33 24931.32\n06b_spindle8aACC anterior cingulate 1.92 342.21 18237.49 19462.92\n07a_pyramidal13aACC anterior cingulate 1.37 325.73 6254.53 8738.01\n07b_pyramidal14aACC anterior cingulate 1.67 350.40 16053.07 22772.96\n07b_spindle9aACC anterior cingulate 1.75 437.87 21344.83 27307.48\n08a_spindle13aACC anterior cingulate 1.74 814.45 9911.07 14113.32\n08o_pyramidal11aFI fronto-insula 1.91 421.68 11512.38 24326.94\n09o_spindle7aFI fronto-insula 2.90 472.87 22052.10 27905.89\n09o_spindle8aFI fronto-insula 2.05 376.73 11923.76 15189.32\n10a_pyramidal15aACC anterior cingulate 1.40 341.48 8522.11 10960.84\n10a_spindle18aACC anterior cingulate 1.57 457.90 5895.17 7219.28\n11a_pyramidal16aACC anterior cingulate 1.27 486.31 8807.01 12263.84\n11o_pyramidal12aFI fronto-insula 1.91 369.34 70786.62 79516.92\n12a_spindle19aACC anterior cingulate 2.05 431.22 12178.08 15618.67\n12o_spindle9aFI fronto-insula 3.41 305.31 29983.79 36678.18\n13o_spindle10aFI fronto-insula 2.69 516.92 39866.55 46022.15\n15o_spindle12aFI fronto-insula 3.60 604.57 53192.65 79170.43\n16o_spindle13aFI fronto-insula 2.17 364.66 17467.88 18888.13\n17o_pyramidal13aFI fronto-insula 1.89 340.77 11004.30 21167.19\n18o_pyramidal14aFI fronto-insula 1.74 288.41 69851.56 78999.20\n19o_spindle14aFI fronto-insula 2.18 232.21 10507.15 12905.43\n20o_pyramidal15aFI fronto-insula 1.82 383.18 22344.32 27667.19\n21o_spindle15aFI fronto-insula 2.36 286.33 17567.69 29466.53\n22o_pyramidal16aFI fronto-insula 1.94 585.35 18776.05 29441.43\n23o_spindle16aFI fronto-insula 1.67 420.05 10429.13 13482.93\n24o_pyramidal17aFI fronto-insula 2.04 371.99 40986.40 47377.09\n25o_pyramidal18aFI fronto-insula 1.80 364.05 18587.13 23572.15\n25o_spindle17aFI fronto-insula 1.79 358.70 7897.44 13563.26\n26o_spindle18aFI fronto-insula 2.27 442.65 52911.93 56084.44\n27o_spindle19aFI fronto-insula 1.73 275.08 20640.14 25423.96\n28o_spindle20aFI fronto-insula 3.00 520.69 35442.59 51267.07\n28o_spindle21aFI fronto-insula 2.62 298.57 35579.06 37783.31\n29o_spindle22aFI fronto-insula 3.52 402.84 62928.22 83279.12\n31o_pyramidal19aFI fronto-insula 2.26 303.55 65950.80 86376.72","category":"page"},{"location":"neurons/","page":"Neurons","title":"Neurons","text":"The neuron models and the measurement data are from (Ascoli 2007) and (Watson 2006).","category":"page"},{"location":"generated/matrix_formalism/","page":"Matrix Formalism","title":"Matrix Formalism","text":"EditURL = \"https://github.com/SpinDoctorMRI/SpinDoctor.jl/blob/main/examples/matrix_formalism.jl\"","category":"page"},{"location":"generated/matrix_formalism/#Matrix-Formalism","page":"Matrix Formalism","title":"Matrix Formalism","text":"","category":"section"},{"location":"generated/matrix_formalism/","page":"Matrix Formalism","title":"Matrix Formalism","text":"In this example we will consider the matrix formalism approach for a geometry of cylinders.","category":"page"},{"location":"generated/matrix_formalism/","page":"Matrix Formalism","title":"Matrix Formalism","text":"using SpinDoctor\nusing LinearAlgebra\n\nif haskey(ENV, \"GITHUB_ACTIONS\")\n    using CairoMakie\nelse\n    using GLMakie\nend\n\nsetup = CylinderSetup(;\n    name = \"Slice\",\n    ncell = 3,\n    rmin = 2.0,\n    rmax = 6.0,\n    dmin = 0.2,\n    dmax = 0.3,\n    height = 1.0,\n    bend = 0.0,\n    twist = 0.0,\n    ecs_shape = :convex_hull,\n    ecs_ratio = 0.5,\n)","category":"page"},{"location":"generated/matrix_formalism/","page":"Matrix Formalism","title":"Matrix Formalism","text":"We also define coefficients for the different cell compartments :in (axon), :out (myelin), and :ecs (ECS).","category":"page"},{"location":"generated/matrix_formalism/","page":"Matrix Formalism","title":"Matrix Formalism","text":"coeffs = coefficients(\n    setup;\n    D = (; in = 0.002 * I(3), out = 0.002 * I(3), ecs = 0.002 * I(3)),\n    T₂ = (; in = Inf, out = Inf, ecs = Inf),\n    ρ = (; in = 1.0, out = 1.0, ecs = 1.0),\n    κ = (; in_out = 1e-4, out_ecs = 1e-4, in = 0.0, out = 0.0, ecs = 0.0),\n    γ = 2.67513e-4,\n)","category":"page"},{"location":"generated/matrix_formalism/","page":"Matrix Formalism","title":"Matrix Formalism","text":"We then proceed to build the geometry and finite element mesh.","category":"page"},{"location":"generated/matrix_formalism/","page":"Matrix Formalism","title":"Matrix Formalism","text":"mesh, = create_geometry(setup; recreate = true)\nplot_mesh(mesh)","category":"page"},{"location":"generated/matrix_formalism/","page":"Matrix Formalism","title":"Matrix Formalism","text":"The mesh looks good, so we may then proceed to assemble the biological model and the associated finite element matrices.","category":"page"},{"location":"generated/matrix_formalism/","page":"Matrix Formalism","title":"Matrix Formalism","text":"model = Model(; mesh, coeffs...);\nmatrices = assemble_matrices(model);\nnothing #hide","category":"page"},{"location":"generated/matrix_formalism/","page":"Matrix Formalism","title":"Matrix Formalism","text":"We may also compute some useful quantities, including a scalar diffusion coefficient from the diffusion tensors.","category":"page"},{"location":"generated/matrix_formalism/","page":"Matrix Formalism","title":"Matrix Formalism","text":"volumes = get_cmpt_volumes(model.mesh)\nD_avg = 1 / 3 * tr.(model.D)' * volumes / sum(volumes)","category":"page"},{"location":"generated/matrix_formalism/","page":"Matrix Formalism","title":"Matrix Formalism","text":"The eigenfunctions of the diffusive part of the Bloch-Torrey operator forms a good basis for the finite element function space. The basis may be truncated at a certain level, thus reducing the number of degrees of freedom. We here opt for 400 eigenfunctions.","category":"page"},{"location":"generated/matrix_formalism/","page":"Matrix Formalism","title":"Matrix Formalism","text":"laplace = Laplace(; model, matrices, neig_max = 400)\nlap_eig = solve(laplace)","category":"page"},{"location":"generated/matrix_formalism/","page":"Matrix Formalism","title":"Matrix Formalism","text":"The resulting eigenvalues may be represented as length scales, describing the wavelength of the eigenfunctions.","category":"page"},{"location":"generated/matrix_formalism/","page":"Matrix Formalism","title":"Matrix Formalism","text":"length_scales = eig2length.(lap_eig.values, D_avg)","category":"page"},{"location":"generated/matrix_formalism/","page":"Matrix Formalism","title":"Matrix Formalism","text":"We may also further truncate the eigenfunction basis, if we are satisfied skipping features below a threshold length scale of 3 micrometers.","category":"page"},{"location":"generated/matrix_formalism/","page":"Matrix Formalism","title":"Matrix Formalism","text":"length_scale = 3\nλ_max = length2eig(length_scale, D_avg)\nlap_eig = limit_lengthscale(lap_eig, λ_max)","category":"page"},{"location":"generated/matrix_formalism/","page":"Matrix Formalism","title":"Matrix Formalism","text":"Each of the resulting eigenfunctions is represented in the same way as the initial magnetization field ρ.","category":"page"},{"location":"generated/matrix_formalism/","page":"Matrix Formalism","title":"Matrix Formalism","text":"ncompartment, nboundary = size(mesh.facets)\nfig = Figure()\nfor i = 1:3, j = 1:4\n    ieig = 6(i - 1) + j\n    ϕ_cmpts = split_field(mesh, lap_eig.funcs[:, ieig])\n    ax = Axis3(fig[i, j]; title = \"n = $ieig, ℓ = $(length_scales[ieig])\", aspect = :data)\n    nboundary = size(mesh.facets, 2)\n    scene = nothing\n    first = true\n    for icmpt = 1:ncompartment, iboundary = 1:nboundary\n        facets = mesh.facets[icmpt, iboundary]\n        points = mesh.points[icmpt]\n        mesh!(ax, points', facets', color = ϕ_cmpts[icmpt], shading = false)\n    end\nend\nfig","category":"page"},{"location":"generated/matrix_formalism/","page":"Matrix Formalism","title":"Matrix Formalism","text":"We observe that the first functions have large features, while the higher-index functions have more rapidly varying features. We may now choose a gradient and compute the projection of magnetization field onto the truncated basis.","category":"page"},{"location":"generated/matrix_formalism/","page":"Matrix Formalism","title":"Matrix Formalism","text":"dir = [1.0, 0.0, 0.0]\nprofile = CosOGSE(5000.0, 5000.0, 2)\nb = 1000\ng = √(b / int_F²(profile)) / coeffs.γ\ngradient = ScalarGradient(dir, profile, g)","category":"page"},{"location":"generated/matrix_formalism/","page":"Matrix Formalism","title":"Matrix Formalism","text":"The matrix formalism problem is solved in the same way as the BTPDE. The time profile is approximated on 500 points, since it is non-constant.","category":"page"},{"location":"generated/matrix_formalism/","page":"Matrix Formalism","title":"Matrix Formalism","text":"mf = MatrixFormalism(; model, matrices, lap_eig)\nξ = solve(mf, gradient; ninterval = 500)","category":"page"},{"location":"generated/matrix_formalism/","page":"Matrix Formalism","title":"Matrix Formalism","text":"The resulting magnetization field may be plotted.","category":"page"},{"location":"generated/matrix_formalism/","page":"Matrix Formalism","title":"Matrix Formalism","text":"plot_field(model.mesh, ξ)","category":"page"},{"location":"generated/matrix_formalism/","page":"Matrix Formalism","title":"Matrix Formalism","text":"","category":"page"},{"location":"generated/matrix_formalism/","page":"Matrix Formalism","title":"Matrix Formalism","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/solve_btpde/","page":"Solve BTPDE","title":"Solve BTPDE","text":"EditURL = \"https://github.com/SpinDoctorMRI/SpinDoctor.jl/blob/main/examples/solve_btpde.jl\"","category":"page"},{"location":"generated/solve_btpde/#Solve-BTPDE","page":"Solve BTPDE","title":"Solve BTPDE","text":"","category":"section"},{"location":"generated/solve_btpde/","page":"Solve BTPDE","title":"Solve BTPDE","text":"We start by loading SpinDoctor and a Makie plotting backend.","category":"page"},{"location":"generated/solve_btpde/","page":"Solve BTPDE","title":"Solve BTPDE","text":"using SpinDoctor\nusing LinearAlgebra\n\nif haskey(ENV, \"GITHUB_ACTIONS\")\n    using CairoMakie\nelse\n    using GLMakie\nend","category":"page"},{"location":"generated/solve_btpde/","page":"Solve BTPDE","title":"Solve BTPDE","text":"The built in geometry recipes allow for making various cell configuration. We here consider the case of three twisted axons immersed in an extracellular space (ECS).","category":"page"},{"location":"generated/solve_btpde/","page":"Solve BTPDE","title":"Solve BTPDE","text":"setup = CylinderSetup(;\n    name = \"some-very-real-axons\",\n    ncell = 3,\n    rmin = 2.0,\n    rmax = 6.0,\n    dmin = 0.2,\n    dmax = 0.3,\n    height = 40.0,\n    bend = 0.0,\n    twist = π / 4,\n    include_in = false,\n    in_ratio = 0.6,\n    ecs_shape = :convex_hull,\n    ecs_ratio = 0.5,\n)","category":"page"},{"location":"generated/solve_btpde/","page":"Solve BTPDE","title":"Solve BTPDE","text":"We also define coefficients for the different cell compartments :in (axon), :out (myelin), and :ecs (ECS).","category":"page"},{"location":"generated/solve_btpde/","page":"Solve BTPDE","title":"Solve BTPDE","text":"coeffs = coefficients(\n    setup;\n    D = (; in = 0.002 * I(3), out = 0.002 * I(3), ecs = 0.002 * I(3)),\n    T₂ = (; in = Inf, out = Inf, ecs = Inf),\n    ρ = (; in = 1.0, out = 1.0, ecs = 1.0),\n    κ = (; in_out = 1e-4, out_ecs = 1e-4, in = 0.0, out = 0.0, ecs = 0.0),\n    γ = 2.67513e-4,\n)","category":"page"},{"location":"generated/solve_btpde/","page":"Solve BTPDE","title":"Solve BTPDE","text":"The following line creates a random cell configuration for our cylinder setup, generates a surface triangulation and calls TetGen to create a tetrahedral finite element mesh. The compartments and boundaries will be ordered in the same way as coeffs.","category":"page"},{"location":"generated/solve_btpde/","page":"Solve BTPDE","title":"Solve BTPDE","text":"mesh, = create_geometry(setup)","category":"page"},{"location":"generated/solve_btpde/","page":"Solve BTPDE","title":"Solve BTPDE","text":"The resulting mesh can be plotted in 3D provided a Makie backend is loaded.","category":"page"},{"location":"generated/solve_btpde/","page":"Solve BTPDE","title":"Solve BTPDE","text":"plot_mesh(mesh)","category":"page"},{"location":"generated/solve_btpde/","page":"Solve BTPDE","title":"Solve BTPDE","text":"The mesh looks good, so we can proceed with the assembly our biological model and the associated finite element matrices.","category":"page"},{"location":"generated/solve_btpde/","page":"Solve BTPDE","title":"Solve BTPDE","text":"model = Model(; mesh, coeffs...)\nmatrices = assemble_matrices(model)","category":"page"},{"location":"generated/solve_btpde/","page":"Solve BTPDE","title":"Solve BTPDE","text":"The Bloch-Torrey PDE takes a magnetic field gradient pulse sequence as an input. Here we consider a ScalarGradient with a PGSE time profile.","category":"page"},{"location":"generated/solve_btpde/","page":"Solve BTPDE","title":"Solve BTPDE","text":"dir = [1.0, 0.0, 0.0]\nprofile = PGSE(2000.0, 6000.0)\nb = 1000\ng = √(b / int_F²(profile)) / coeffs.γ\ngradient = ScalarGradient(dir, profile, g)","category":"page"},{"location":"generated/solve_btpde/","page":"Solve BTPDE","title":"Solve BTPDE","text":"SpinDoctor provides a solve function, which has the same base signature for all diffusion MRI problems. The BTPDE is one such problem. They generally take a gradient sequence as an input.","category":"page"},{"location":"generated/solve_btpde/","page":"Solve BTPDE","title":"Solve BTPDE","text":"btpde = BTPDE(; model, matrices)\nξ = solve(btpde, gradient)","category":"page"},{"location":"generated/solve_btpde/","page":"Solve BTPDE","title":"Solve BTPDE","text":"Here, ξ is a vector containing the complex-valued magnetization at all degrees of freedom at the echo time TE. We may compute the resulting signal as follows:","category":"page"},{"location":"generated/solve_btpde/","page":"Solve BTPDE","title":"Solve BTPDE","text":"compute_signal(matrices.M, ξ)","category":"page"},{"location":"generated/solve_btpde/","page":"Solve BTPDE","title":"Solve BTPDE","text":"The global mass matrix M is used to compute the integral. We may however be interested in the compartment-wise signals. This requires splitting the magnetization field into the respective compartments. The compartment mass matrices are also available.","category":"page"},{"location":"generated/solve_btpde/","page":"Solve BTPDE","title":"Solve BTPDE","text":"ξ_cmpts = split_field(mesh, ξ)\ncompute_signal.(matrices.M_cmpts, ξ_cmpts)","category":"page"},{"location":"generated/solve_btpde/","page":"Solve BTPDE","title":"Solve BTPDE","text":"The final magnetization can be visualized using the plot_field function.","category":"page"},{"location":"generated/solve_btpde/","page":"Solve BTPDE","title":"Solve BTPDE","text":"plot_field(mesh, ξ)","category":"page"},{"location":"generated/solve_btpde/","page":"Solve BTPDE","title":"Solve BTPDE","text":"In this example, we have computed the complex transverse water proton magnetization field using the finite element method. The measured diffusion MRI signal is the integral of this field, and other quantities of interest, such as the apparent diffusion coefficient (ADC), or the effective diffusion tensor, may easily be obtained from this reference field. Directly solving the BTPDE is thus considered to be the \"gold standard\" for computing these quantities, as arbitrary precision may be obtained.","category":"page"},{"location":"generated/solve_btpde/","page":"Solve BTPDE","title":"Solve BTPDE","text":"However, this is also often the most computationally expensive approach. In the following examples, we will consider some other specialized methods provided by SpinDoctor, each having their own domains of validity, use cases, and computational footprints.","category":"page"},{"location":"generated/solve_btpde/","page":"Solve BTPDE","title":"Solve BTPDE","text":"","category":"page"},{"location":"generated/solve_btpde/","page":"Solve BTPDE","title":"Solve BTPDE","text":"This page was generated using Literate.jl.","category":"page"},{"location":"theory/theory/#Theory","page":"Theory","title":"Theory","text":"","category":"section"},{"location":"theory/theory/#Abbreviations","page":"Theory","title":"Abbreviations","text":"","category":"section"},{"location":"theory/theory/","page":"Theory","title":"Theory","text":"ADC, Apparent Diffusion Coefficient;\nBT, Bloch-Torrey;\nBTPDE, Bloch-Torrey PDE;\nDMRI, Diffusion MRI;\nECS, Extra-Cellular Space;\nFEM, Finite Element Method;\nHADC, Homogenized ADC model;\nHARDI, High Angular Resolution Diffusion Imaging;\nMF, Matrix Formalism;\nMRI, Magnetic Resonance Imaging;\nODE, Ordinary Differential Equation;\nOGSE, Oscillating Gradient Spin Echo sequence;\nPDE, Partial Differential Equation;\nPGSE, Pulsed-Gradient Spin Echo sequence;\nSTA, Short Time Approximation.","category":"page"},{"location":"theory/theory/#Geometrical-configuration","page":"Theory","title":"Geometrical configuration","text":"","category":"section"},{"location":"theory/theory/","page":"Theory","title":"Theory","text":"In SpinDoctor, we consider a domain Omega = bigcup_i = 1^N_textcmpt Omega_i subset mathbbR^3 consisting of N_textcmpt compartments Omega_i_1 leq i leq N_textcmpt. The permeable interface between two compartments is denoted by Gamma_i j = Omega_i cap Omega_j for i neq j, (i j) in 1 dots N_textcmpt^2. For i = j, we let Gamma_ii = emptyset for the ease of notation. Finally, let partial Omega denote the outer boundary of the domain, and Gamma_i = Omega_i cap partial Omega its restriction to Omega_i. Note that for compartments that do not touch, we have Gamma_i j = emptyset. Similarly, we have Gamma_i = emptyset for compartments that do not touch the outer boundary.","category":"page"},{"location":"theory/matrix_formalism/#Matrix-formalism","page":"Matrix Formalism","title":"Matrix formalism","text":"","category":"section"},{"location":"theory/matrix_formalism/#Eigenvalue-decomposition-of-the-generalized-Laplace-operator","page":"Matrix Formalism","title":"Eigenvalue decomposition of the generalized Laplace operator","text":"","category":"section"},{"location":"theory/matrix_formalism/","page":"Matrix Formalism","title":"Matrix Formalism","text":"Let (phi lambda) be the L^2-normalized eigenfunctions and eigenvalues of the generalized Laplace operator nabla cdot mathbfD nabla, defined almost everywhere on the domain Omega = bigcup_i = 1^N_textcmpt Omega_i. Denoting phi^i the restriction of phi to compartment Omega_i, the eigenfunctions respect the following set of equations, for (i j) in 1 dots N_textcmpt^2:","category":"page"},{"location":"theory/matrix_formalism/","page":"Matrix Formalism","title":"Matrix Formalism","text":"-nabla cdot mathbfD_i nabla phi^i(vecx) = lambda phi^i(vecx) quad vecx in\nOmega_i quad i in 1 dots N_textcmpt","category":"page"},{"location":"theory/matrix_formalism/","page":"Matrix Formalism","title":"Matrix Formalism","text":"where the boundary conditions are the same as for the BTPDE:","category":"page"},{"location":"theory/matrix_formalism/","page":"Matrix Formalism","title":"Matrix Formalism","text":"beginalignedat3\n    mathbfD_i nabla phi^i(vecx) cdot vecn_i(vecx)  = -mathbfD_j nabla\n    phi^j(vecx) cdot vecn_j(vecx) quad   vecx in Gamma_i j quad (i\n    j) in 1 dots N_textcmpt^2  \n    mathbfD_i nabla phi^i(vecx) cdot vecn_i(vecx)  = kappa_i j left(c_i j\n    phi^j(vecx) - c_j iphi^i(vecx)right) quad   vecx in Gamma_i j\n    quad (i j) in 1 dots N_textcmpt^2 \n    mathbfD_i nabla phi^i(vecx) cdot vecn_i(vecx)  = -kappa_i phi^i(vecx)\n    quad   vecx in Gamma_i quad i in 1 dots N_textcmpt \nendalignedat","category":"page"},{"location":"theory/matrix_formalism/","page":"Matrix Formalism","title":"Matrix Formalism","text":"Let the solutions (phi lambda) to the above equations be denoted by left(phi_n lambda_n)right_n in mathbbN^*. We assume the non-negative real-valued eigenvalues are ordered in non-decreasing order:","category":"page"},{"location":"theory/matrix_formalism/","page":"Matrix Formalism","title":"Matrix Formalism","text":"0 = lambda_1 leq lambda_2 leq lambda_3 leq dots","category":"page"},{"location":"theory/matrix_formalism/","page":"Matrix Formalism","title":"Matrix Formalism","text":"If the domain Omega consists of only one contiguous group of compartments connected through a chain of permeable membranes, only the first eigenvalue will be zero, and the corresponding eigenfunction will be the only constant function. If there are N_textgroup geq 2 groups of connected compartments completely separated by interior hard wall membranes, the first N_textgroup eigenvalues will be zero:","category":"page"},{"location":"theory/matrix_formalism/","page":"Matrix Formalism","title":"Matrix Formalism","text":"0 = lambda_1 = dots = lambda_N_textgroup  lambda_N_textgroup + 1 leq dots","category":"page"},{"location":"theory/matrix_formalism/","page":"Matrix Formalism","title":"Matrix Formalism","text":"and there will be N_textgroup corresponding groupwise constant eigenfunctions. In the latter case, the equations may be rewritten separately for each connected subdomain to obtain a set of eigenvalues with a multiplicity of one, but the formulation is also valid in the global form with multiple zero eigenvalues. These two formulations will lead to an identical eigenfunction basis (up to a linear combination for the eigenvalues with multiplicity higher than one), where the basis of each subdomain is a subset of the global eigenfunction basis.","category":"page"},{"location":"theory/matrix_formalism/","page":"Matrix Formalism","title":"Matrix Formalism","text":"Let mathbfL be the diagonal matrix containing the first N_texteig Laplace eigenvalues:","category":"page"},{"location":"theory/matrix_formalism/","page":"Matrix Formalism","title":"Matrix Formalism","text":"mathbfL = operatornamediag(lambda_1 lambda_2 dots lambda_N_texteig)in\nR^N_texteig times N_texteig","category":"page"},{"location":"theory/matrix_formalism/","page":"Matrix Formalism","title":"Matrix Formalism","text":"Then the matrix mathbfL represents the generalized Laplace operator -nabla cdot mathbfD nabla in the truncated Laplace eigenfunction basis.","category":"page"},{"location":"theory/matrix_formalism/#Bloch-Torrey-operator-in-the-Laplace-eigenfunction-basis","page":"Matrix Formalism","title":"Bloch-Torrey operator in the Laplace eigenfunction basis","text":"","category":"section"},{"location":"theory/matrix_formalism/","page":"Matrix Formalism","title":"Matrix Formalism","text":"Let mathbfA(vecg) be the N_texteig times N_texteig matrix defined by:","category":"page"},{"location":"theory/matrix_formalism/","page":"Matrix Formalism","title":"Matrix Formalism","text":"mathbfA(vecg) = g_x mathbfA^x + g_y mathbfA^y + g_z mathbfA^z","category":"page"},{"location":"theory/matrix_formalism/","page":"Matrix Formalism","title":"Matrix Formalism","text":"where vecg = (g_x g_y g_z)^mathsfT is the gradient vector and mathbfA^x, mathbfA^y, and mathbfA^z are three symmetric N_texteig times N_texteig matrices whose entries are the first order moments in the coordinate directions of the product of pairs of eigenfunctions:","category":"page"},{"location":"theory/matrix_formalism/","page":"Matrix Formalism","title":"Matrix Formalism","text":"beginalignedat3\n    A_mn^x  = int_Omega x  phi_m(vecx) phi_n(vecx)  mathrmd\n    Omega(vecx) quad   (m n) in 1 dots N_texteig^2 \n    A_mn^y  = int_Omega y  phi_m(vecx) phi_n(vecx)  mathrmd\n    Omega(vecx) quad   (m n) in 1 dots N_texteig^2 \n    A_mn^z  = int_Omega z  phi_m(vecx) phi_n(vecx)  mathrmd\n    Omega(vecx) quad   (m n) in 1 dots N_texteig^2\nendalignedat","category":"page"},{"location":"theory/matrix_formalism/","page":"Matrix Formalism","title":"Matrix Formalism","text":"Similarly, let mathbfT be the N_texteig times N_texteig Laplace relaxation matrix defined by","category":"page"},{"location":"theory/matrix_formalism/","page":"Matrix Formalism","title":"Matrix Formalism","text":"T_mn = int_Omega frac1T_2(vecx) phi_m(vecx) phi_n(vecx)  mathrmd\nOmega(vecx) quad (mn) in 1 dots N_texteig^2","category":"page"},{"location":"theory/matrix_formalism/","page":"Matrix Formalism","title":"Matrix Formalism","text":"Then the general time dependent Bloch-Torrey operator","category":"page"},{"location":"theory/matrix_formalism/","page":"Matrix Formalism","title":"Matrix Formalism","text":"-nabla cdot mathbfD nabla + frac1T_2 + underlinemathrmi gamma vecg(t)\ncdot vecx quad t in 0 T_textecho","category":"page"},{"location":"theory/matrix_formalism/","page":"Matrix Formalism","title":"Matrix Formalism","text":"in the truncated Laplace eigenfunction basis (phi_j)_j = 1 dots N_texteig is given by the complex-valued matrix","category":"page"},{"location":"theory/matrix_formalism/","page":"Matrix Formalism","title":"Matrix Formalism","text":"mathbfK(vecg(t)) = mathbfL + mathbfT + underlinemathrmi gamma\nmathbfA(vecg(t)) quad t in 0 T_textecho","category":"page"},{"location":"theory/matrix_formalism/#Matrix-Formalism-approximation","page":"Matrix Formalism","title":"Matrix Formalism approximation","text":"","category":"section"},{"location":"theory/matrix_formalism/","page":"Matrix Formalism","title":"Matrix Formalism","text":"Denoting vecphi = (phi_1 dots phi_N_texteig)^mathsfT the vector of the first N_texteig Laplace eigenfunctions, we may project the solution to to the Bloch-Torrey PDE onto the truncated Laplace eigenfunction basis:","category":"page"},{"location":"theory/matrix_formalism/","page":"Matrix Formalism","title":"Matrix Formalism","text":"M^textMF(vecx t) = vecphi^mathsfT(vecx) vecnu(t)","category":"page"},{"location":"theory/matrix_formalism/","page":"Matrix Formalism","title":"Matrix Formalism","text":"where the vector of coefficients vecnu = (nu_1 dots nu_N_texteig)^mathsfT  0 T_textecho to mathbbC^N_texteig is the solution to","category":"page"},{"location":"theory/matrix_formalism/","page":"Matrix Formalism","title":"Matrix Formalism","text":"fracmathrmd vecnumathrmd t = -mathbfK(vecg(t)) vecnu(t) quad t\nin 0 T_textecho","category":"page"},{"location":"theory/matrix_formalism/","page":"Matrix Formalism","title":"Matrix Formalism","text":"The initial coefficients are given by","category":"page"},{"location":"theory/matrix_formalism/","page":"Matrix Formalism","title":"Matrix Formalism","text":"vecnu(0) = int_Omega rho(vecx) vecphi(vecx)  mathrmd Omega(vecx)","category":"page"},{"location":"theory/matrix_formalism/","page":"Matrix Formalism","title":"Matrix Formalism","text":"By using a piece-wise constant approximation of the gradient vecg, we obtain","category":"page"},{"location":"theory/matrix_formalism/","page":"Matrix Formalism","title":"Matrix Formalism","text":"vecnu(T_textecho) approx left(prod_i = 1^N_textint mathrme^-delta_i\nmathbfK_iright) vecnu(0) = mathrme^-delta_N_textint\nmathbfK_N_textint dots mathrme^-delta_2 mathbfK_2 mathrme^-delta_1\nmathbfK_1 vecnu(0)","category":"page"},{"location":"theory/matrix_formalism/","page":"Matrix Formalism","title":"Matrix Formalism","text":"where I_i_i = 1 dots N_textint are intervals such that 0 T_textecho = bigcup_i = 1^N_textint I_i, vecg(t) = vecg_i for t in I_i, delta_i = I_i, and mathbfK_i = mathbfK(vecg_i). The constants may be computed through quadrature:","category":"page"},{"location":"theory/matrix_formalism/","page":"Matrix Formalism","title":"Matrix Formalism","text":"vecg_i = frac1delta_iint_I_i vecg(t)  mathrmd t approx frac12\nleft(vecg(min I_i) + vecg(max I_i)right)","category":"page"},{"location":"theory/matrix_formalism/","page":"Matrix Formalism","title":"Matrix Formalism","text":"For the PGSE and double-PGSE sequences vecg(t) = f(t) g vecd, where f(t) in -1 0 1 for all t, the coefficients of the final magnetization are given by","category":"page"},{"location":"theory/matrix_formalism/","page":"Matrix Formalism","title":"Matrix Formalism","text":"vecnu(T_textecho) = mathrme^-deltamathbfK(g vecd)^* mathrme^-(Delta -\ndelta)(mathbfL + mathbfT) mathrme^-delta mathbfK(g vecd vecnu(0)","category":"page"},{"location":"theory/matrix_formalism/","page":"Matrix Formalism","title":"Matrix Formalism","text":"and","category":"page"},{"location":"theory/matrix_formalism/","page":"Matrix Formalism","title":"Matrix Formalism","text":"vecnu(T_textecho) = mathrme^-delta mathbfK(g vecd)^* mathrme^-(Delta\n- delta)(mathbfL + mathbfT) mathrme^-delta mathbfK(g vecd)\nmathrme^-t_textpause(mathbfL\n+ mathbfT) mathrme^-delta mathbfK(g vecd)^* mathrme^-(Delta -\n+ delta)(mathbfL +\nmathbfT) mathrme^-delta mathbfK(g vecd) vecnu(0)","category":"page"},{"location":"theory/matrix_formalism/","page":"Matrix Formalism","title":"Matrix Formalism","text":"respectively. These are the exact solutions, although there may still be truncation errors from N_texteig.","category":"page"},{"location":"theory/matrix_formalism/","page":"Matrix Formalism","title":"Matrix Formalism","text":"The signal is given by","category":"page"},{"location":"theory/matrix_formalism/","page":"Matrix Formalism","title":"Matrix Formalism","text":"S^textMF(f vecg) = vecnu^mathsfT(T_textecho) int_Omega\nvecphi(vecx)  mathrmd Omega(vecx)","category":"page"},{"location":"theory/matrix_formalism/#Apparent-diffusion-coefficient","page":"Matrix Formalism","title":"Apparent diffusion coefficient","text":"","category":"section"},{"location":"theory/matrix_formalism/","page":"Matrix Formalism","title":"Matrix Formalism","text":"From the Matrix Formalism signal, the analytical expression of its ADC for a gradient direction given by a unit vector vecd and a sequence f is the following:","category":"page"},{"location":"theory/matrix_formalism/","page":"Matrix Formalism","title":"Matrix Formalism","text":"D^textMF(vecd f) = frac1Omega sum_n = 1^N_texteig (vecd cdot\nveca_n)^2 lambda_n fracint_0^T_textecho F(t) int_0^t mathrme^-lambda_n(t -\ns) f(s)  mathrmd s  mathrmd t int_0^T_textecho F^2(t)  mathrmd t","category":"page"},{"location":"theory/matrix_formalism/","page":"Matrix Formalism","title":"Matrix Formalism","text":"where the coefficients of the three-row matrix mathbfa = (veca_1^ dots veca_N_texteig) in mathbbR^3 times N_texteig are given by","category":"page"},{"location":"theory/matrix_formalism/","page":"Matrix Formalism","title":"Matrix Formalism","text":"beginsplit\n    a_n^x  = int_Omega x phi_n(vecx)  mathrmd Omega(vecx) \n    a_n^y  = int_Omega y phi_n(vecx)  mathrmd Omega(vecx) \n    a_n^z  = int_Omega z phi_n(vecx)  mathrmd Omega(vecx)\nendsplit\nquad n in 1 dots N_texteig","category":"page"},{"location":"theory/matrix_formalism/","page":"Matrix Formalism","title":"Matrix Formalism","text":"To clarify the relationship between the ADC and the diffusion encoding direction vecd, we rewrite the Matrix Formalism ADC as","category":"page"},{"location":"theory/matrix_formalism/","page":"Matrix Formalism","title":"Matrix Formalism","text":"D^textMF(vecd f) = vecd^mathsfT mathbfD^textMF(f) vecd","category":"page"},{"location":"theory/matrix_formalism/","page":"Matrix Formalism","title":"Matrix Formalism","text":"where the Matrix Formalism effective diffusion tensor is given by","category":"page"},{"location":"theory/matrix_formalism/","page":"Matrix Formalism","title":"Matrix Formalism","text":"mathbfD^textMF(f) = frac1Omega sum_n = 1^N_texteig j_n(f) veca_n\nveca_n^mathsfT = frac1Omega mathbfa mathbfj(f) mathbfa^mathsfT","category":"page"},{"location":"theory/matrix_formalism/","page":"Matrix Formalism","title":"Matrix Formalism","text":"with mathbfj(f) = operatornamediagleft(j_1(f) dots j_N_texteig(f)right) in mathbbR^N_texteig times N_texteig depending on f:","category":"page"},{"location":"theory/matrix_formalism/","page":"Matrix Formalism","title":"Matrix Formalism","text":"j_n(f) = lambda_n fracint_0^T_textecho F(t) int_0^t e^-lambda_n(t - s) f(s) \nmathrmd s  mathrmd tint_0^T_textecho F^2(t)  mathrmd t quad n in\n1 dots N_texteig","category":"page"},{"location":"theory/matrix_formalism/","page":"Matrix Formalism","title":"Matrix Formalism","text":"In the case of a constant initial spin density rho, we also allow for computing the Matrix Formalism Gaussian Approximation (MFGA) signal, given as","category":"page"},{"location":"theory/matrix_formalism/","page":"Matrix Formalism","title":"Matrix Formalism","text":"S^textMFGA(g f vecd) = rho Omega expleft(-vecd^mathsfT\nmathbfD^textMF(f) vecd  b(g f) right) ","category":"page"},{"location":"theory/matrix_formalism/#Eigenfunction-length-scale-and-orientation","page":"Matrix Formalism","title":"Eigenfunction length scale and orientation","text":"","category":"section"},{"location":"theory/matrix_formalism/","page":"Matrix Formalism","title":"Matrix Formalism","text":"On a line segment of length L and diffusivity D_0, the eigenvalues (lambda_1 lambda_2 dots) of the Laplace operator with Neumann boundary conditions are","category":"page"},{"location":"theory/matrix_formalism/","page":"Matrix Formalism","title":"Matrix Formalism","text":"lambda_n = left(fracpi (n - 1)Lright)^2 D_0 quad n = 1 2 dots","category":"page"},{"location":"theory/matrix_formalism/","page":"Matrix Formalism","title":"Matrix Formalism","text":"To make the link between the computed eigenvalue and the spatial scale of the eigenmode, we will convert the computed lambda_n into a length scale:","category":"page"},{"location":"theory/matrix_formalism/","page":"Matrix Formalism","title":"Matrix Formalism","text":"ell(lambda) =\nbegincases\n    + infty quad                                 lambda = 0 \n    pi sqrtfracbarsigmalambda quad  lambda  0\nendcases","category":"page"},{"location":"theory/matrix_formalism/","page":"Matrix Formalism","title":"Matrix Formalism","text":"and characterize the computed eigenmode by ell(lambda_n) instead of lambda_n. The reference diffusivity barsigma is taken as a volume weighted mean of the trace average (spherical part) of (mathbfD_i)_1 leq i leq N_textcmpt:","category":"page"},{"location":"theory/matrix_formalism/","page":"Matrix Formalism","title":"Matrix Formalism","text":"barsigma = frac1Omega int_Omega frac13operatornametr mathbfD(vecx)\n mathrmd Omega(vecx)","category":"page"},{"location":"theory/matrix_formalism/","page":"Matrix Formalism","title":"Matrix Formalism","text":"To characterize the directional contribution of the eigenmode we use the fact that its contribution to the ADC in the direction vecd is j_n(f) (vecd cdot veca_n)^2. We thus call veca_n = (a_n^x a_n^y a_n^z)^mathsfT the \"diffusion direction\" of the nth eigenmode. We remind that the three components of veca_n are the first moments in the 3 canonical basis directions of the associated eigenfunction.","category":"page"},{"location":"theory/discretization/#Finite-element-discretization","page":"Discretization","title":"Finite element discretization","text":"","category":"section"},{"location":"theory/discretization/","page":"Discretization","title":"Discretization","text":"In SpinDoctor, the finite element mesh generation is performed using an external package called Tetgen. Each finite element mesh consists of","category":"page"},{"location":"theory/discretization/","page":"Discretization","title":"Discretization","text":"a list of N_textnode nodes in three dimensions: (mathbfq_1 dots mathbfq_N_textnode) = (mathbfq^x mathbfq^y mathbfq^z)^mathsfT in R^3 times N_textnode;\na list of N_textelement tetrahedral elements (4 times N_textelement indices referencing the nodes).","category":"page"},{"location":"theory/discretization/","page":"Discretization","title":"Discretization","text":"The list of nodes includes double nodes that are placed at the interfaces between compartments connected by permeable membranes. This allows for representing discontinuous magnetization fields M_i and M_j (or phi^i and phi^j) on the same boundary Gamma_i j. To distinguish between the different compartments, let 1 dots N_textnode = bigcup_i = 1^N_textcmpt mathcalI_i with mathcalI_i cap mathcalI_j = emptyset for i neq j. The set mathcalI_i contains the indices of the nodes representing compartment Omega_i, including interface nodes.  In the adjacent compartments, the corresponding interface nodes will have different indices, distinct from mathcalI_i.","category":"page"},{"location":"theory/discretization/","page":"Discretization","title":"Discretization","text":"In SpinDoctor, the finite element space is the space of compartment-wise continuous piecewise linear functions on tetrahedral elements in three dimensions. This space has a set of basis functions whose number is exactly the number of finite element nodes (including double nodes), and that are defined on the entire domain Omega:","category":"page"},{"location":"theory/discretization/","page":"Discretization","title":"Discretization","text":"varphi_k  Omega to 0 1 quad k in 1 dots N_textnode","category":"page"},{"location":"theory/discretization/","page":"Discretization","title":"Discretization","text":"Let the finite element nodes be denoted by mathbfq_1 dots mathbfq_N_textnode. The basis function varphi_k, k in mathcalI_i, is a piece-wise linear function, non-zero on the tetrahedra of Omega_i that touch the node mathbfq_k, and zero on all other tetrahedra (including tetrahedra of other compartments different than Omega_i that do touch mathbfq_k). At the interface Gamma_i j between two compartments, the value of varphi_k is set to be the value it has inside its own compartment, distinct from that of the adjacent compartment. On a tetrahedron of Omega_i that touches mathbfq_k, varphi_k is equal to 1 on mathbfq_k and it is equal to 0 on the other 3 vertices of the tetrahedron. This completely describes the piece-wise linear function. The index sets may then be defined by mathcalI_i = k = 1 dots N_textnode    operatornamesupp (varphi_k) subset Omega_i, the set of indices of the finite element nodal functions whose supports lie entirely within Omega_i.","category":"page"},{"location":"theory/discretization/","page":"Discretization","title":"Discretization","text":"Any function u in the finite element space can be written as a linear combination of the above basis functions:","category":"page"},{"location":"theory/discretization/","page":"Discretization","title":"Discretization","text":"u(vecx) = sum_k = 1^N_textnode alpha_k varphi_k(vecx) =\nbmalpha^mathsfT bmvarphi(vecx) ","category":"page"},{"location":"theory/discretization/","page":"Discretization","title":"Discretization","text":"where bmalpha = (alpha_1 dots alpha_N_textnode)^mathsfT is the vector of coefficients and bmvarphi = (varphi_1 dots varphi_N_textnode)^mathsfT is the vector of finite element nodal basis functions.","category":"page"},{"location":"theory/discretization/","page":"Discretization","title":"Discretization","text":"To discretize the Bloch-Torrey and Laplace operators, we construct the following finite element matrices: mathbfMmathbfSmathbfQinR^N_textnodetimes N_textnode, known in the FEM literature as the mass, stiffness, and flux matrices, respectively. These matrices matrices we need are defined as follows, for (k l) in 1 dots N_textnode:","category":"page"},{"location":"theory/discretization/","page":"Discretization","title":"Discretization","text":"M_kl = int_Omega varphi_k(vecx) varphi_l(vecx)  mathrmd\nOmega(vecx)","category":"page"},{"location":"theory/discretization/","page":"Discretization","title":"Discretization","text":"S_kl = int_Omega mathbfD(vecx) nabla varphi_k(vecx) cdot nabla\nvarphi_l(vecx)  mathrmd Omega(vecx)","category":"page"},{"location":"theory/discretization/","page":"Discretization","title":"Discretization","text":"Q_kl = sum_i = 1^N_textcmpt Q_kl^i + sum_i = 1^N_textcmpt sum_j =\n1^N_textcmpt Q_kl^i j","category":"page"},{"location":"theory/discretization/","page":"Discretization","title":"Discretization","text":"the latter being defined as the sum of interface integrals:","category":"page"},{"location":"theory/discretization/","page":"Discretization","title":"Discretization","text":"Q_kl^i = kappa_i int_Gamma_i varphi_k(vecx) varphi_l(vecx)  mathrmd\nGamma(vecx) quad i in 1 dots N_textcmpt","category":"page"},{"location":"theory/discretization/","page":"Discretization","title":"Discretization","text":"Q_kl^i j =\nbegincases\n    kappa_i j c_j i int_Gamma_i j varphi_k(vecx) varphi_l(vecx) \n    mathrmd Gamma(vecx) quad   (k l) in mathcalI_i^2 \n    -kappa_i j c_i j int_Gamma_i j varphi_k(vecx) varphi_l(vecx) \n    mathrmd Gamma(vecx) quad  (k l) in mathcalI_i times mathcalI_j \n    0 quad  textotherwise\nendcases\nquad (i j) in 1 dots N_textcmpt^2","category":"page"},{"location":"theory/discretization/","page":"Discretization","title":"Discretization","text":"We remind the reader that i and j are compartment indices, while k and l are finite element nodal indices. Note that the above sum formulation counts each interface twice, but only considers the contribution to one side of the boundary at the time. It also correctly accounts for corner nodes (if any) that belong to two different permeable boundaries at the same time.","category":"page"},{"location":"theory/discretization/","page":"Discretization","title":"Discretization","text":"The weak form of the Bloch-Torrey PDE also requires computing the first order moments of the product of pairs of finite element basis functions. We let these three matrices be denoted by mathbfJ^x, mathbfJ^y and mathbfJ^z:","category":"page"},{"location":"theory/discretization/","page":"Discretization","title":"Discretization","text":"J_k l^x = int_Omega x  varphi_k(vecx) varphi_l(vecx)  mathrmd\nOmega(vecx) quad (k l) in 1 dots N_textnode^2","category":"page"},{"location":"theory/discretization/","page":"Discretization","title":"Discretization","text":"J_k l^y = int_Omega y  varphi_k(vecx) varphi_l(vecx)  mathrmd\nOmega(vecx) quad (k l) in 1 dots N_textnode^2","category":"page"},{"location":"theory/discretization/","page":"Discretization","title":"Discretization","text":"J_k l^z = int_Omega z  varphi_k(vecx) varphi_l(vecx)  mathrmd\nOmega(vecx) quad (k l) in 1 dots N_textnode^2","category":"page"},{"location":"theory/discretization/","page":"Discretization","title":"Discretization","text":"where vecx = (x y z)^mathsfT. For a given gradient vector vecg = (g_x g_y g_z)^mathsfT, we define","category":"page"},{"location":"theory/discretization/","page":"Discretization","title":"Discretization","text":"mathbfJ(vecg) = g_x mathbfJ^x + g_y mathbfJ^y + g_z mathbfJ^z","category":"page"},{"location":"theory/discretization/","page":"Discretization","title":"Discretization","text":"In addition, we define the finite element relaxation matrix mathbfR in mathbbR^N_textnode times N_textnode given by","category":"page"},{"location":"theory/discretization/","page":"Discretization","title":"Discretization","text":"R_kl = int_Omega frac1T_2(vecx)  varphi_k(vecx) varphi_l(vecx) \nmathrmd Omega(vecx) quad (k l) in 1 dots N_textnode^2","category":"page"},{"location":"theory/discretization/","page":"Discretization","title":"Discretization","text":"In SpinDoctor, these matrices are assembled from local element matrices and the assembly process is based on vectorized routines of, which replace expensive loops over elements by operations with 3-dimensional arrays. All local element matrices in the assembly of mathbfS, mathbfM, and mathbfQ are evaluated at the same time and stored in a full matrix of size 4 times 4 times N_textelement, where N_textelement denotes the number of tetrahedral elements.","category":"page"},{"location":"theory/discretization/","page":"Discretization","title":"Discretization","text":"The matrices mathbfJ^x, mathbfJ^y, and mathbfJ^z are assembled as coordinate weighted mass matrices, where the three coordinate functions vecx mapsto x, y, z act as nodal weights in the assembly process, given by mathbfq^x, mathbfq^y, mathbfq^z; the vectors of x, y, and z coordinates of the finite element nodes.","category":"page"},{"location":"theory/discretization/","page":"Discretization","title":"Discretization","text":"With compartment-wise constant T_2-relaxation times, mathbfR is a block-diagonally scaled version of the mass matrix mathbfM, where the weights are the inverses of the relaxation times.","category":"page"},{"location":"theory/discretization/#Finite-element-solution-to-the-Bloch-Torrey-PDE","page":"Discretization","title":"Finite element solution to the Bloch-Torrey PDE","text":"","category":"section"},{"location":"theory/discretization/","page":"Discretization","title":"Discretization","text":"The solution to the Bloch-Torrey partial differential equation may be projected onto the finite element nodal basis (varphi_k)_1 leq k leq N_textnode, in which case it is given by","category":"page"},{"location":"theory/discretization/","page":"Discretization","title":"Discretization","text":"M(vecxt) = sum_k = 1^N_textnode\nxi_k(t)varphi_k(vecx) = bmxi^mathsfT(t) bmvarphi(vecx)","category":"page"},{"location":"theory/discretization/","page":"Discretization","title":"Discretization","text":"where bmvarphi = (varphi_1dotsvarphi_N_textnode)^mathsfT in mathbbR^N_textnode is the vector of finite element basis functions and the function bmxi = (xi_1 dots xi_N_textnode)^mathsfT  0 T_textecho to mathbbC^N_textnode is the solution to the following system of ordinary differential equations (ODE):","category":"page"},{"location":"theory/discretization/","page":"Discretization","title":"Discretization","text":"mathbfM fracmathrmd bmximathrmd t = -left(mathbfS + mathbfQ + mathbfR +\nunderlinemathrmi gamma mathbfJ(vecg(t)) right) bmxi(t)","category":"page"},{"location":"theory/discretization/#Finite-element-solution-to-the-HADC-model","page":"Discretization","title":"Finite element solution to the HADC model","text":"","category":"section"},{"location":"theory/discretization/","page":"Discretization","title":"Discretization","text":"Similarly, given an isolated compartment Omega and a scalar gradient vecg(t) = f(t) g vecd, the solution to the HADC model, omega, may be obtained by solving the equation","category":"page"},{"location":"theory/discretization/","page":"Discretization","title":"Discretization","text":"mathbfM fracmathrmd bmzetamathrmd t = - mathbfS bmzeta(t) + F(t)\nmathbfG mathbfD vecd","category":"page"},{"location":"theory/discretization/","page":"Discretization","title":"Discretization","text":"where F(t) = int_0^t f(t)  mathrmd t, bmzeta = (zeta_1 dots zeta_N_textnode)  0 T_textecho to mathbbR^N_textnode is the unknown vector of coefficients of the solution omega(vecx t) = bmzeta^mathsfT(t) bmvarphi(vecx), bmvarphi = (varphi_1 dots varphi_N_textnode) is the vector of finite element basis functions, and mathbfG in mathbbR^N_textnode times 3 is given by","category":"page"},{"location":"theory/discretization/","page":"Discretization","title":"Discretization","text":"mathbfG = sum_k = 1^N_textnode int_partial Omega varphi_k(vecx)\nbmvarphi(vecx) vecn^mathsfT(vecx)  mathrmdGamma(vecx)","category":"page"},{"location":"theory/discretization/","page":"Discretization","title":"Discretization","text":"where vecn = (n_x n_y n_z)^mathsfT is the outwards unit normal. This three-column matrix represents the components of the boundary integral of the quantity F(t) vecd^mathsfT mathbfD vecn, where the constant diffusivity and gradient sequence dependent part F(t) vecd^mathsfT mathbfD has been factored out. They can thus be assembled independently of the gradient sequence, and be reused when solving for multiple sequences or directions. They are assembled using the same routine as for mathbfQ.","category":"page"},{"location":"theory/discretization/","page":"Discretization","title":"Discretization","text":"The boundary integral h is then given by","category":"page"},{"location":"theory/discretization/","page":"Discretization","title":"Discretization","text":"h(t) = frac1Omega bmzeta^mathsfT(t) mathbfG vecd","category":"page"},{"location":"theory/discretization/","page":"Discretization","title":"Discretization","text":"where Omega = sum_jk = 1^N_textnode M_jk is computed using the mass matrix.","category":"page"},{"location":"theory/discretization/#Finite-element-Matrix-Formalism-signal-representation","page":"Discretization","title":"Finite element Matrix Formalism signal representation","text":"","category":"section"},{"location":"theory/discretization/","page":"Discretization","title":"Discretization","text":"Both of the above ODEs are of dimension N_textnode, the number of finite element nodes. The finite element discretized Matrix Formalism representation uses a different approach, limiting the problem size to N_texteig, the number of Laplace eigenfunctions (of which the choice is further explored in section. But first we need to solve an eigenvalue problem involving matrices of size N_textnodetimes N_textnode. The finite element discretization changes the continuous Laplace operator eigenvalue problem into the following discrete, generalized matrix eigenvalue problem: find (lambda mathbfp) in mathbbR times mathbbR^N_textnode such that","category":"page"},{"location":"theory/discretization/","page":"Discretization","title":"Discretization","text":"lambda mathbfM mathbfp = (mathbfS + mathbfQ) mathbfp","category":"page"},{"location":"theory/discretization/","page":"Discretization","title":"Discretization","text":"of which we will retain the N_texteig smallest eigenvalues and corresponding eigenvectors (lambda_n mathbfp_n)_1 leq n leq N_texteig, with N_texteig leq N_textnode. Note however that there are in total N_textnode solutions to the problem. Moving back to the space of functions (the function space P_1), the eigenfunction phi_n(vecx) associated to the eigenvalue lambda_n is then","category":"page"},{"location":"theory/discretization/","page":"Discretization","title":"Discretization","text":"phi_n(vecx) = sum_k = 1^N_textnode p_n^k varphi_k(vecx) =\nmathbfp_n^mathsfT bmvarphi(vecx) quad n in 1 dots N_texteig","category":"page"},{"location":"theory/discretization/","page":"Discretization","title":"Discretization","text":"where the entries of the eigenvector mathbfp_n are the coefficients of the eigenfunction phi_n in the finite element basis. Using matrix notation, this conversion can also be written bmphi = mathbfP^mathsfT bmvarphi, where bmvarphi = (varphi_1 dots varphi_N_textnode)^mathsfT, bmphi = (phi_1 dots phi_N_texteig)^mathsfT, and mathbfP = (mathbfp_1 dots mathbfp_N_texteig) in mathbbR^N_textnode times N_texteig. The integrals of the finite element discretized eigenfunctions are then given by bmPhi = int_Omega bmphi(vecx)  mathrmd Omega(vecx) = mathbfP^mathsfT mathbfM mathbfo, where mathbfo = (1 dots 1)^mathsfT in mathbbR^N_textnode. Similarly, the coefficients of the initial spin density in the finite element discretized eigenfunction basis are given by bmnu = int_Omega rho(vecx) bmphi(vecx)  mathrmd Omega(vecx) = mathbfP^mathsfT mathbfM bmrho, where bmrho = (rho_i(k))_1 leq k leq N_textnode in mathbbR^N_textnode and i(k) in 1 dots N_textcmpt is such that k in mathcalI_i(k).","category":"page"},{"location":"theory/discretization/","page":"Discretization","title":"Discretization","text":"Then it is clear that the first order moments of the product of pairs of Laplace eigenfunctions can be written as:","category":"page"},{"location":"theory/discretization/","page":"Discretization","title":"Discretization","text":"mathbfA^u = mathbfP^mathsfTmathbfJ^umathbfP quad u = x y z","category":"page"},{"location":"theory/discretization/","page":"Discretization","title":"Discretization","text":"These three matrices are computed using a total of six matrix-matrix multiplications. Similarly, the eigenfunction basis relaxation matrix \\mathbf{T} may be obtained from the finite element nodal basis relaxation matrix \\mathbf{R} by","category":"page"},{"location":"theory/discretization/","page":"Discretization","title":"Discretization","text":"mathbfT = mathbfP^mathsfT mathbfR mathbfP","category":"page"},{"location":"api/#API-Reference","page":"API Reference","title":"API Reference","text":"","category":"section"},{"location":"api/#Gradients","page":"API Reference","title":"Gradients","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"These functions deal with gradient pulse sequences.","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"GeneralGradient\nScalarGradient\nPGSE\nDoublePGSE\nCosOGSE\nSinOGSE\nintegral\nint_F²\nintervals\nisconstant\nechotime","category":"page"},{"location":"api/#SpinDoctor.GeneralGradient","page":"API Reference","title":"SpinDoctor.GeneralGradient","text":"GeneralGradient(g⃗)\n\nGeneral gradient sequence vecg(t) in mathbbR^3. The direction and amplitude may vary in time.\n\n\n\n\n\n","category":"type"},{"location":"api/#SpinDoctor.ScalarGradient","page":"API Reference","title":"SpinDoctor.ScalarGradient","text":"ScalarGradient(dir, profile, amplitude)\n\nGradient sequence with amplitude amplitude, normal direction dir and scalar time profile profile.\n\nThe direction is constant, while the amplitude is controlled by the time profile.\n\nThe direction is normalized upon construction.\n\n\n\n\n\n","category":"type"},{"location":"api/#SpinDoctor.PGSE","page":"API Reference","title":"SpinDoctor.PGSE","text":"f = PGSE(δ, Δ)\n\nPulsed Gradient Spin Echo sequence with pulse duration δ and time between pulses Δ-δ.\n\n\n\n\n\n","category":"type"},{"location":"api/#SpinDoctor.DoublePGSE","page":"API Reference","title":"SpinDoctor.DoublePGSE","text":"f = DoublePGSE(δ, Δ)\n\nDouble Pulsed Gradient Spin Echo sequence with four pulses of duration δ, separated by pauses of duration Δ-δ, 0, and Δ-δ repsectively.\n\n\n\n\n\n","category":"type"},{"location":"api/#SpinDoctor.CosOGSE","page":"API Reference","title":"SpinDoctor.CosOGSE","text":"f = CosOGSE(δ, Δ, nperiod)\n\nOscillating Gradient Spin Echo sequence with two cos-pulses of duration δ separated by a pause of duration Δ-δ for nperiod periods per pulse.\n\n\n\n\n\n","category":"type"},{"location":"api/#SpinDoctor.SinOGSE","page":"API Reference","title":"SpinDoctor.SinOGSE","text":"f = SinOGSE(δ, Δ, nperiod)\n\nOscillating Gradient Spin Echo sequence with two sin-pulses of duration δ separated by a pause of duration Δ-δ for nperiod periods per pulse.\n\n\n\n\n\n","category":"type"},{"location":"api/#SpinDoctor.integral","page":"API Reference","title":"SpinDoctor.integral","text":"integral(f, t = echotime(f))\n\nIntegral of time profile f between 0 and t. Unless specified, the echotime is used as the upper integral limit.\n\nFor the PGSE, SinOGSE, CosOGSE and DoublePGSE sequences, analytical expressions are available. Otherwise a numerical integral is computed.\n\n\n\n\n\n","category":"function"},{"location":"api/#SpinDoctor.int_F²","page":"API Reference","title":"SpinDoctor.int_F²","text":"int_F²(f)\n\nCompute the time profile contribution to the b-value given the time profile f. The b-value is given by\n\nb = γ^2 * g^2 * int_F²(f)\n\nwhere γ is the gyromagnetic ratio of the water proton and g is the gradient amplitude.\n\n\n\n\n\n","category":"function"},{"location":"api/#SpinDoctor.intervals","page":"API Reference","title":"SpinDoctor.intervals","text":"intervals(f)\n\nGet characteristic intervals of the time profile f.\n\n\n\n\n\n","category":"function"},{"location":"api/#SpinDoctor.isconstant","page":"API Reference","title":"SpinDoctor.isconstant","text":"isconstant(profile)\n\nReturn true if the time profile profile is intervalwise constant.\n\n\n\n\n\n","category":"function"},{"location":"api/#SpinDoctor.echotime","page":"API Reference","title":"SpinDoctor.echotime","text":"echotime(f::TimeProfile)\n\nGet echo time TE of the time profile f, which is the end of the last characteristic interval.\n\n\n\n\n\nechotime(grad::AbstractGradient)\n\nGet echo time TE of gradient.\n\n\n\n\n\n","category":"function"},{"location":"api/#Geometry","page":"API Reference","title":"Geometry","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"assemble_matrices\nsplit_mesh\nsplit_field\nget_cmpt_volumes\nModel\ninitial_conditions","category":"page"},{"location":"api/#SpinDoctor.assemble_matrices","page":"API Reference","title":"SpinDoctor.assemble_matrices","text":"assemble_matrices(model)\n\nAssemble finite element matrices.\n\n\n\n\n\n","category":"function"},{"location":"api/#SpinDoctor.split_mesh","page":"API Reference","title":"SpinDoctor.split_mesh","text":"split_mesh(mesh_all)\n\nSplit global mesh into compartments.\n\n\n\n\n\n","category":"function"},{"location":"api/#SpinDoctor.split_field","page":"API Reference","title":"SpinDoctor.split_field","text":"split_field(mesh, ξ)\n\nSplit the field ξ into a vector containing a view of each compartment. \n\n\n\n\n\n","category":"function"},{"location":"api/#SpinDoctor.get_cmpt_volumes","page":"API Reference","title":"SpinDoctor.get_cmpt_volumes","text":"get_cmpt_volumes(mesh)\n\nGet compartment volumes.\n\n\n\n\n\n","category":"function"},{"location":"api/#SpinDoctor.Model","page":"API Reference","title":"SpinDoctor.Model","text":"Model(; mesh, ρ, D, T₂, κ, γ)\n\nFinite element discretized biological model with initial spin densities ρ, diffusion tensors D, T₂-relaxation times T₂, wall permeabilities κ, and gyromacnetic ratio γ. The vectors ρ, D, T₂, are of length ncompartment, while κ is of length nboundary.\n\n\n\n\n\n","category":"type"},{"location":"api/#SpinDoctor.initial_conditions","page":"API Reference","title":"SpinDoctor.initial_conditions","text":"initial_conditions(model)\n\nGet initial conditions at all degrees of freedom.\n\n\n\n\n\n","category":"function"},{"location":"api/#Postprocessing","page":"API Reference","title":"Postprocessing","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"savefield\ncompute_adc_sta\nfit_adc\nfit_tensors\nplot_mesh\nplot_field","category":"page"},{"location":"api/#SpinDoctor.savefield","page":"API Reference","title":"SpinDoctor.savefield","text":"savefield(mesh, ξ, filename::String; fieldname = \"Magnetization\")\n\nSave field ξ to a VTK file. It may then be visualized in Paraview.\n\n\n\n\n\n","category":"function"},{"location":"api/#SpinDoctor.compute_adc_sta","page":"API Reference","title":"SpinDoctor.compute_adc_sta","text":"compute_adc_sta(model)\n\nCompute the ADC for each compartment in the short diffusion time regime.\n\n\n\n\n\n","category":"function"},{"location":"api/#SpinDoctor.fit_adc","page":"API Reference","title":"SpinDoctor.fit_adc","text":"fit_adc(bvalues, signals)\n\nFit the apparent diffusion coefficient (ADC) using a polynomial logfit of the normalized signals signals against the b-values bvalues.\n\n\n\n\n\n","category":"function"},{"location":"api/#SpinDoctor.fit_tensors","page":"API Reference","title":"SpinDoctor.fit_tensors","text":"fit_tensors(directions, adcs)\n\nFit effective diffusion tensors to directionalized ADCs. The six components of the symmetric diffusion tensors are fitted by least squares to the gradient directions and resulting ADCs.\n\n\n\n\n\n","category":"function"},{"location":"api/#SpinDoctor.plot_mesh","page":"API Reference","title":"SpinDoctor.plot_mesh","text":"plot_mesh(femesh, compartments = 1:ncompartment)\n\nPlot finite element mesh, with a subset of the compartments.\n\n\n\n\n\n","category":"function"},{"location":"api/#SpinDoctor.plot_field","page":"API Reference","title":"SpinDoctor.plot_field","text":"plot_field(femesh, ξ)\n\nPlot field ξ on the finite element mesh.\n\n\n\n\n\n","category":"function"},{"location":"api/#Problems","page":"API Reference","title":"Problems","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"SpinDoctor allows for considering a wide range of diffusion MRI problems. These can be solved for using the solve function.","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"BTPDE\nHADC\nKarger\nLaplace\nMatrixFormalism\nAnalyticalLaplace\nAnalyticalMatrixFormalism\nIntervalConstantSolver\nsolve\nsolve_multigrad","category":"page"},{"location":"api/#SpinDoctor.BTPDE","page":"API Reference","title":"SpinDoctor.BTPDE","text":"GeneralBTPDE(; model, matrices)\n\nBloch-Torrey PDE problem.\n\n\n\n\n\n","category":"type"},{"location":"api/#SpinDoctor.HADC","page":"API Reference","title":"SpinDoctor.HADC","text":"HADC(; model, matrices)\n\nHADC problem.\n\n\n\n\n\n","category":"type"},{"location":"api/#SpinDoctor.Karger","page":"API Reference","title":"SpinDoctor.Karger","text":"Karger(; model, difftensors)\n\nKarger problem.\n\n\n\n\n\n","category":"type"},{"location":"api/#SpinDoctor.Laplace","page":"API Reference","title":"SpinDoctor.Laplace","text":"Laplace(; model, matrices, neig_max)\n\nLaplace eigenvalue problem.\n\n\n\n\n\n","category":"type"},{"location":"api/#SpinDoctor.MatrixFormalism","page":"API Reference","title":"SpinDoctor.MatrixFormalism","text":"MatrixFormalism(; model, matrices, lap_eig)\n\nMatrix formalism problem. Given a Laplace eigendecomposition lap_eig, this problem consists of computing the MF magnetization.\n\n\n\n\n\n","category":"type"},{"location":"api/#SpinDoctor.AnalyticalLaplace","page":"API Reference","title":"SpinDoctor.AnalyticalLaplace","text":"AnalyticalLaplace(; ρ, r, D, W, T₂, γ, dim, eiglim, eigstep)\n\nAnalytical radial Laplace eigenvalue problem.\n\n\n\n\n\n","category":"type"},{"location":"api/#SpinDoctor.AnalyticalMatrixFormalism","page":"API Reference","title":"SpinDoctor.AnalyticalMatrixFormalism","text":"AnalyticalMatrixFormalism(; analytical_laplace, lap_mat, volumes)\n\nAnalytical Matrix formalism problem. Given a radial Laplace eigendecomposition analytical_laplace, this problem consists of computing the MF compartment signals.\n\n\n\n\n\n","category":"type"},{"location":"api/#SpinDoctor.IntervalConstantSolver","page":"API Reference","title":"SpinDoctor.IntervalConstantSolver","text":"IntervalConstantSolver(; θ = 0.5, timestep)\n\nBTPDE solver specialized on intervalwise constant ScalarGradients, e.g PGSE, DoublePGSE. Raises an error for other gradients.\n\n\n\n\n\n","category":"type"},{"location":"api/#SpinDoctor.solve","page":"API Reference","title":"SpinDoctor.solve","text":"solve(problem::Laplace)\n\nCompute the Laplace eigenvalues, eigenfunctions and first order moments of products of pairs of eigenfunctions.\n\n\n\n\n\nsolve(problem::MatrixFormalism, gradient; ninterval = 500)\n\nSolve for magnetization using Matrix Formalism.\n\n\n\n\n\nsolve(problem::AnalyticalLaplace)\n\nSolve analytical Laplace eigenvalue problem for symmetrical geometries.\n\n\n\n\n\nsolve(problem::AnalyticalMatrixFormalism, gradient)\n\nCompute the signal in a multilayered cylinder or sphere using an analytical matrix formalism solution.\n\nThis function is based on the following articles and corresponding code:     [1] D. S. Grebenkov, NMR Survey of Reflected Brownian Motion,         Rev. Mod.Phys. 79, 1077 (2007)     [2] D. S. Grebenkov, Pulsed-gradient spin-echo monitoring of restricted diffusion in         multilayered structures, J. Magn. Reson. 205, 181-195 (2010).\n\n\n\n\n\nsolve(\n    problem::GeneralBTPDE,\n    gradient,\n    odesolver = QNDF();\n    abstol = 1e-6,\n    reltol = 1e-4,\n    callbacks = [].\n)\n\nSolve the Bloch-Torrey partial differential equation using P1 finite elements in space and odesolver in time.\n\n\n\n\n\nfunction solve(\n    problem::BTPDE,\n    gradient::ScalarGradient,\n    odesolver::IntervalConstantSolver;\n    callbacks = [],\n)\n\nSolve the Bloch-Torrey partial differential equation using P1 finite elements in space and a theta-rule in time. This time stepping scheme requires a degree of implicitness θ and a time step Δt:\n\nθ = 0.5: Crank-Nicolson (second order)\nθ = 1.0: Implicit Euler (first order)\n\nThe function only works for interval-wise constant ScalarGradients, and errors otherwise.\n\n\n\n\n\nsolve(problem::Karger, gradient, odesolver = MagnusGL6(); timestep)\n\nSolve the finite pulse Karger model (FPK) using precomputed effective diffusion tensors difftensors.\n\n\n\n\n\nsolve(problem::HADC, gradient::ScalarGradient, odesolver = QNDF();\n    abstol = 1e-6,\n    reltol = 1e-4,\n)\n\nCompute the ADC using a homogenized ADC model (HADC). This is currently only implemented for scalar gradients.\n\n\n\n\n\n","category":"function"},{"location":"api/#SpinDoctor.solve_multigrad","page":"API Reference","title":"SpinDoctor.solve_multigrad","text":"solve_multigrad(problem, gradients, args...; kwargs...)\n\nSolve problem for multiple magnetic field gradients.\n\n\n\n\n\n","category":"function"},{"location":"api/#Matrix-formalism","page":"API Reference","title":"Matrix formalism","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"length2eig\neig2length\nlimit_lengthscale\ncompute_mf_diffusion_tensor","category":"page"},{"location":"api/#SpinDoctor.length2eig","page":"API Reference","title":"SpinDoctor.length2eig","text":"length2eig(length, D)\n\nConvert length scale to Laplace eigenvalue.\n\n\n\n\n\n","category":"function"},{"location":"api/#SpinDoctor.eig2length","page":"API Reference","title":"SpinDoctor.eig2length","text":"eig2length(λ, D)\n\nConvert Laplace eigenvalue to length scale.\n\n\n\n\n\n","category":"function"},{"location":"api/#SpinDoctor.limit_lengthscale","page":"API Reference","title":"SpinDoctor.limit_lengthscale","text":"limit_lengthscale(lap_eig, λ_max)\n\nOnly keep modes with length scales larger than minimum\n\n\n\n\n\n","category":"function"},{"location":"api/#SpinDoctor.compute_mf_diffusion_tensor","page":"API Reference","title":"SpinDoctor.compute_mf_diffusion_tensor","text":"compute_mf_diffusion_tensor(mesh, M, lap_eig, gradient::ScalarGradient)\n\nCompute effective diffusion tensors using the matrix formalism.\n\n\n\n\n\n","category":"function"},{"location":"api/#Utils","page":"API Reference","title":"Utils","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"unitcircle\nunitsphere\ncompute_signal","category":"page"},{"location":"api/#SpinDoctor.unitcircle","page":"API Reference","title":"SpinDoctor.unitcircle","text":"unitcircle(ndirection; half = false, normal = [0, 0, 1])\n\nCreate ndirection directions unformly distributed on the unit circle defined by normal.\n\nIf half is true, the directions lie on a half-circle instead of the whole circle. \n\n\n\n\n\n","category":"function"},{"location":"api/#SpinDoctor.unitsphere","page":"API Reference","title":"SpinDoctor.unitsphere","text":"unitsphere(ndirection; half = false, normal = [0, 0, 1])\n\nCreate ndirection directions unformly distributed on the unit sphere.\n\nIf half is true, the points will be discributed on the hemisphere defined by normal.\n\n\n\n\n\n","category":"function"},{"location":"api/#SpinDoctor.compute_signal","page":"API Reference","title":"SpinDoctor.compute_signal","text":"compute_signal(M, ξ)\n\nCompute signal from magnetization ξ, using the mass matrix M for integration.\n\nGiven a mesh mesh and a vector of compartment mass matrices M_cmpts, a vector of compartment signals may be obtained by compute_signal.(M_cmpts, split_field(mesh, ξ)).\n\n\n\n\n\n","category":"function"},{"location":"api/#Callbacks","page":"API Reference","title":"Callbacks","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Callbacks are called after every time step when solving the BTPDE.","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Printer\nVTKWriter\nPlotter","category":"page"},{"location":"api/#SpinDoctor.Printer","page":"API Reference","title":"SpinDoctor.Printer","text":"Printer(; nupdate = 1)\n\nPrint time stepping information to the console.\n\n\n\n\n\n","category":"type"},{"location":"api/#SpinDoctor.VTKWriter","page":"API Reference","title":"SpinDoctor.VTKWriter","text":"VTKWriter(; nupdate = 1, dir = \"output\", filename = \"solution\")\n\nWrite magnetization field to a VTK file after every nupdate timestep. The files are stored in a ParaView data collection file (PVD). The magnetization time series may be visualized in ParaView by opening the file \"$dir/$filename.pvd\". The compartments are labeled.\n\n\n\n\n\n","category":"type"},{"location":"api/#SpinDoctor.Plotter","page":"API Reference","title":"SpinDoctor.Plotter","text":"Plotter(; nupdate = 1)\n\nPlot the evolution of the BTPDE during time stepping. This requires loading the GLMakie plotting backend (]add GLMakie; using GLMakie). The plot is updated every nupdate time step. The resulting figure contains a plot of the time profile, total signal attenuation, and magnetization field (complex magnitude and phase shift).\n\n\n\n\n\n","category":"type"},{"location":"api/#Recipes","page":"API Reference","title":"Recipes","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"SpinDoctor comes with pre-configures recipes for creating finite element meshes of plates, cylinders, spheres, and neurons.","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"PlateSetup\nCylinderSetup\nSphereSetup\nNeuronSetup\ncoefficients\nanalytical_coefficients\ncreate_geometry","category":"page"},{"location":"api/#SpinDoctor.PlateSetup","page":"API Reference","title":"SpinDoctor.PlateSetup","text":"Setup recipe for a set of stacked plates.\n\n\n\n\n\n","category":"type"},{"location":"api/#SpinDoctor.CylinderSetup","page":"API Reference","title":"SpinDoctor.CylinderSetup","text":"Setup recipe for a set of cylinders immersed in a ECS.\n\n\n\n\n\n","category":"type"},{"location":"api/#SpinDoctor.SphereSetup","page":"API Reference","title":"SpinDoctor.SphereSetup","text":"Setup recipe for a set of spheres immersed in a ECS.\n\n\n\n\n\n","category":"type"},{"location":"api/#SpinDoctor.NeuronSetup","page":"API Reference","title":"SpinDoctor.NeuronSetup","text":"Setup recipe for a neuron, possibly wrapped in a ECS.\n\n\n\n\n\n","category":"type"},{"location":"api/#SpinDoctor.coefficients","page":"API Reference","title":"SpinDoctor.coefficients","text":"coefficients(setup; D, T₂, ρ, κ, γ)\n\nOrder coefficients compartment arrays.\n\n\n\n\n\n","category":"function"},{"location":"api/#SpinDoctor.analytical_coefficients","page":"API Reference","title":"SpinDoctor.analytical_coefficients","text":"analytical_coefficients(setup, coeffs)\n\nGet coefficients for the analytical module.\n\n\n\n\n\n","category":"function"},{"location":"api/#SpinDoctor.create_geometry","page":"API Reference","title":"SpinDoctor.create_geometry","text":"create_geometry(setup; recreate = true)\n\nCreate cells, surfaces and finite element mesh. If recreate = false, previous geometry will be reused.\n\nThis function does the following:\n\nCheck geometry setup consistency\nCreate or load cell configuration\nCreate or load surface triangulation\nCall TetGen\nDeform domain\nSplit mesh into compartments\n\nFor custom geometries with more than one compartment, call split_mesh directly instead. This requires facet and element labels.\n\n\n\n\n\n","category":"function"},{"location":"theory/adc/#adc","page":"Apparent Diffusion Coefficient","title":"Apparent Diffusion Coefficient","text":"","category":"section"},{"location":"theory/adc/","page":"Apparent Diffusion Coefficient","title":"Apparent Diffusion Coefficient","text":"Consider a unidirectional gradient vecg(t) = g f(t) vecd parametrized by an amplitude g  0, time profile f  0 T_textecho to -1 1 and direction vecd with  vecd  = 1.","category":"page"},{"location":"theory/adc/","page":"Apparent Diffusion Coefficient","title":"Apparent Diffusion Coefficient","text":"Some commonly used time profiles (diffusion-encoding sequences) are:","category":"page"},{"location":"theory/adc/","page":"Apparent Diffusion Coefficient","title":"Apparent Diffusion Coefficient","text":"The pulsed-gradient spin echo (PGSE) sequence:\nf(t) =\nbegincases\n1 quad  t_1 leq t leq t_1+delta \n-1 quad  t_1 + Delta  t leq t_1 + Delta + delta \n0 quad  textotherwise\nendcases\nThe double pulsed-gradient spin echo (DPGSE) sequence:\nf(t) = f_delta Delta(t) + f_delta Deltaleft(t - (Delta + delta +\nt_textpause) right)\nwhere f_delta Delta is a normal PGSE sequence;\nThe oscillating gradient spin echo (OGSE) sequence (here, cos-OGSE):\nf(t) =\nbegincases\n    cosleft(n frac2pidelta (t - t_1)right) quad  t_1  t leq t_1\n    + delta \n    -cosleft(n frac2 pidelta (t - Delta - t_1)right) quad  t_1 + Delta  t\n    leq t_1 + Delta + delta \n    0 quad  textotherwise\nendcases","category":"page"},{"location":"theory/adc/","page":"Apparent Diffusion Coefficient","title":"Apparent Diffusion Coefficient","text":"where t_1 geq 0 and t_1 + Delta geq T_textecho  2.","category":"page"},{"location":"theory/adc/#B-value","page":"Apparent Diffusion Coefficient","title":"B-value","text":"","category":"section"},{"location":"theory/adc/","page":"Apparent Diffusion Coefficient","title":"Apparent Diffusion Coefficient","text":"In a DMRI experiment, f is usually fixed, while g or vecd are varied. S is usually plotted against a quantity called the b-value. The b-value depends on f and g:","category":"page"},{"location":"theory/adc/","page":"Apparent Diffusion Coefficient","title":"Apparent Diffusion Coefficient","text":"b(g f) = gamma^2 g^2 int_0^T_textecho left( int_0^t f(s)  mathrmd s right)^2\n mathrmdt","category":"page"},{"location":"theory/adc/","page":"Apparent Diffusion Coefficient","title":"Apparent Diffusion Coefficient","text":"For PGSE, the b-value is:","category":"page"},{"location":"theory/adc/","page":"Apparent Diffusion Coefficient","title":"Apparent Diffusion Coefficient","text":"b(g delta Delta) = gamma^2 g^2 delta^2 left( Delta - delta  3 right)","category":"page"},{"location":"theory/adc/","page":"Apparent Diffusion Coefficient","title":"Apparent Diffusion Coefficient","text":"For the cosine OGSE with integer number of periods n in each of the two durations delta, the corresponding b-value is:","category":"page"},{"location":"theory/adc/","page":"Apparent Diffusion Coefficient","title":"Apparent Diffusion Coefficient","text":"b(g delta) = gamma^2 g^2 fracdelta^34 n^2 pi^2 = gamma^2 g^2\nfracdeltaomega^2","category":"page"},{"location":"theory/adc/","page":"Apparent Diffusion Coefficient","title":"Apparent Diffusion Coefficient","text":"The reason for these definitions is that in a homogeneous medium, the signal attenuation is exp(-vecd^mathsfT mathbfD_0 vecd b), where mathbfD_0 is the intrinsic diffusion tensor.","category":"page"},{"location":"theory/adc/#ADC","page":"Apparent Diffusion Coefficient","title":"ADC","text":"","category":"section"},{"location":"theory/adc/","page":"Apparent Diffusion Coefficient","title":"Apparent Diffusion Coefficient","text":"An important quantity that can be derived from the dMRI signal is the \"Apparent Diffusion Coefficient\" (ADC), which gives an indication of the root mean squared distance travelled by water molecules in the gradient direction vecd, averaged over all starting positions:","category":"page"},{"location":"theory/adc/","page":"Apparent Diffusion Coefficient","title":"Apparent Diffusion Coefficient","text":"D_textADC = left -fracpartialpartial b logfracS(b)S(0)rightvert_b=0","category":"page"},{"location":"theory/adc/#Fitting-the-ADC-from-the-dMRI-signal","page":"Apparent Diffusion Coefficient","title":"Fitting the ADC from the dMRI signal","text":"","category":"section"},{"location":"theory/adc/","page":"Apparent Diffusion Coefficient","title":"Apparent Diffusion Coefficient","text":"We numerically compute ADC by a polynomial fit of","category":"page"},{"location":"theory/adc/","page":"Apparent Diffusion Coefficient","title":"Apparent Diffusion Coefficient","text":"logfracS(b)S_textinitial approx c_0+c_1b+dots+c_n b^n","category":"page"},{"location":"theory/adc/","page":"Apparent Diffusion Coefficient","title":"Apparent Diffusion Coefficient","text":"increasing n from 1 onwards until we get the value of c_1 to be stable within a numerical tolerance, where S_textinitial = int_Omega rho(vecx)  mathrmd Omega(vecx). The first coefficient is given by c_0 = log fracS(0)S_textinitial, which is equal to zero if T_2i = infty for all i.","category":"page"},{"location":"theory/adc/","page":"Apparent Diffusion Coefficient","title":"Apparent Diffusion Coefficient","text":"The ADC may be interpreted as a correction to the intrinsic diffusion coefficient, taking into account the deviation from the free diffusion arising from interior interfaces, non-isotropic diffusion, fluid movements etc. For suffiently small b-values, the signal attenuation is given by","category":"page"},{"location":"theory/adc/","page":"Apparent Diffusion Coefficient","title":"Apparent Diffusion Coefficient","text":"mathrme^-D_textADC b","category":"page"},{"location":"theory/adc/","page":"Apparent Diffusion Coefficient","title":"Apparent Diffusion Coefficient","text":"Another quantity of interest is a slight generalization of the ADC – an effective diffusion tensor mathbfD_texteff. The six coefficients of this symmetric positive tensor is fitted to best approximate the following signal attenuation, for all directions vecd:","category":"page"},{"location":"theory/adc/","page":"Apparent Diffusion Coefficient","title":"Apparent Diffusion Coefficient","text":"mathrme^-vecg^mathsfT mathbfD_texteff vecd b","category":"page"},{"location":"theory/adc/","page":"Apparent Diffusion Coefficient","title":"Apparent Diffusion Coefficient","text":"The resulting ADC in direction vecd is then given by","category":"page"},{"location":"theory/adc/","page":"Apparent Diffusion Coefficient","title":"Apparent Diffusion Coefficient","text":"D_textADC(vecd) = vecd^mathsfT mathbfD_texteff vecd","category":"page"},{"location":"theory/adc/#HADC","page":"Apparent Diffusion Coefficient","title":"HADC","text":"","category":"section"},{"location":"theory/adc/","page":"Apparent Diffusion Coefficient","title":"Apparent Diffusion Coefficient","text":"In a previous work, a PDE model for the time-dependent ADC was obtained starting from the Bloch-Torrey equation, using homogenization techniques. In the case of negligible water exchange between compartments (low permeability), there is no coupling between the compartments, at least to the quadratic order in g, which is the ADC term. The ADC in compartment Omega is given by","category":"page"},{"location":"theory/adc/","page":"Apparent Diffusion Coefficient","title":"Apparent Diffusion Coefficient","text":"D_textHADC(vecd f) = vecd^mathsfT mathbfD vecd -\nfracint_0^T_textecho F(t) h(t)  mathrmdtint_0^T_textecho F(t)^2 \nmathrmd t","category":"page"},{"location":"theory/adc/","page":"Apparent Diffusion Coefficient","title":"Apparent Diffusion Coefficient","text":"where F(t) = int_0^t f(s)  mathrmds and","category":"page"},{"location":"theory/adc/","page":"Apparent Diffusion Coefficient","title":"Apparent Diffusion Coefficient","text":"h(t) = frac1Omega int_partial Omega omega(vecx t)  vecd cdot\nvecn(vecx)  mathrmd Gamma(vecx)","category":"page"},{"location":"theory/adc/","page":"Apparent Diffusion Coefficient","title":"Apparent Diffusion Coefficient","text":"is a quantity related to the directional gradient of a function omega that is the solution of the homogeneous diffusion equation with Neumann boundary condition and zero initial condition:","category":"page"},{"location":"theory/adc/","page":"Apparent Diffusion Coefficient","title":"Apparent Diffusion Coefficient","text":"beginalignedat2\n    fracpartialpartial t omega(vecx t)  = nabla cdot left(mathbfD nabla\n    omega(vecx t)right) quad   (vecx t) in Omega times 0 T_textecho\n    \n    omega(vecx 0)  = 0 quad   vecx in Omega \n    mathbfD nabla omega(vecx t) cdot vecn  = F(t) mathbfD vecd cdot\n    vecn quad    vecx in partial Omega\nendalignedat","category":"page"},{"location":"theory/adc/","page":"Apparent Diffusion Coefficient","title":"Apparent Diffusion Coefficient","text":"vecn being the outward normal. The above set of equations comprise the homogenized model that we call the HADC model.","category":"page"},{"location":"theory/adc/#STA","page":"Apparent Diffusion Coefficient","title":"Short diffusion time approximation","text":"","category":"section"},{"location":"theory/adc/","page":"Apparent Diffusion Coefficient","title":"Apparent Diffusion Coefficient","text":"A well-known formula for the ADC in the short diffusion time regime is the following short time approximation (STA):","category":"page"},{"location":"theory/adc/","page":"Apparent Diffusion Coefficient","title":"Apparent Diffusion Coefficient","text":"D_textSTA = left(1 - frac4sqrtD_03 sqrtpisqrtDelta fracAd V\nright) D_0","category":"page"},{"location":"theory/adc/","page":"Apparent Diffusion Coefficient","title":"Apparent Diffusion Coefficient","text":"where dfracAV is the surface to volume ratio, d is the spatial dimension and D_0 = vecd^mathsfT mathbfD vecd is the intrinsic diffusion coefficient in the gradient direction. In the above formula, the pulse duration delta is assumed to be very small compared to Delta. A recent correction to the above formula , taking into account the finite pulse duration delta and the gradient direction vecd, is the following:","category":"page"},{"location":"theory/adc/","page":"Apparent Diffusion Coefficient","title":"Apparent Diffusion Coefficient","text":"D_textSTA = left(1 - frac4 sqrtD_03 sqrtpi C_deltaDelta\nfracA_vecdV right) D_0","category":"page"},{"location":"theory/adc/","page":"Apparent Diffusion Coefficient","title":"Apparent Diffusion Coefficient","text":"where","category":"page"},{"location":"theory/adc/","page":"Apparent Diffusion Coefficient","title":"Apparent Diffusion Coefficient","text":"A_vecd = int_partial Omega left(vecd cdot vecn(vecx)right)^2 \nmathrmd Gamma(vecx) = vecd^mathsfT mathbfN vecd","category":"page"},{"location":"theory/adc/","page":"Apparent Diffusion Coefficient","title":"Apparent Diffusion Coefficient","text":"with mathbfN = int_partial Omega vecn(vecx) vecn^mathsfT(vecx)  mathrmd Gamma(vecx) and","category":"page"},{"location":"theory/adc/","page":"Apparent Diffusion Coefficient","title":"Apparent Diffusion Coefficient","text":"C_delta Delta = dfrac435 dfracleft(Delta + delta right)^7  2+\nleft(Delta - deltaright)^7  2 - 2 left(delta^ 7  2 + Delta^7  2\nright)delta^2 left( Delta - delta  3right) = sqrtDelta left(1 + dfrac13\ndfracdeltaDelta - dfrac835 left(dfracdeltaDeltaright)^3  2 + dots\nright)","category":"page"},{"location":"theory/adc/","page":"Apparent Diffusion Coefficient","title":"Apparent Diffusion Coefficient","text":"When delta ll Delta, the value C_delta Delta is approximately sqrtDelta.","category":"page"},{"location":"getting_started/#Getting-started","page":"Getting Started","title":"Getting started","text":"","category":"section"},{"location":"getting_started/#Installation","page":"Getting Started","title":"Installation","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"To install SpinDoctor, run the following commands:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"git clone https://github.com/SpinDoctorMRI/SpinDoctor.jl\ncd SpinDoctor.jl\njulia --project\n]instantiate","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"The last line takes you into the package mode (]). The instantiate command then installs all dependencies.","category":"page"},{"location":"generated/hardi/","page":"High Angular Resolution","title":"High Angular Resolution","text":"EditURL = \"https://github.com/SpinDoctorMRI/SpinDoctor.jl/blob/main/examples/hardi.jl\"","category":"page"},{"location":"generated/hardi/#High-angular-resolution-diffusion-imaging","page":"High Angular Resolution","title":"High angular resolution diffusion imaging","text":"","category":"section"},{"location":"generated/hardi/","page":"High Angular Resolution","title":"High Angular Resolution","text":"In this example we will compute the signal using the same gradient sequence in many different directions.","category":"page"},{"location":"generated/hardi/#Building-a-biological-model","page":"High Angular Resolution","title":"Building a biological model","text":"","category":"section"},{"location":"generated/hardi/","page":"High Angular Resolution","title":"High Angular Resolution","text":"We start by loading SpinDoctor and a Makie plotting backend.","category":"page"},{"location":"generated/hardi/","page":"High Angular Resolution","title":"High Angular Resolution","text":"using SpinDoctor\nusing LinearAlgebra\n\nif haskey(ENV, \"GITHUB_ACTIONS\")\n    using CairoMakie\nelse\n    using GLMakie\nend","category":"page"},{"location":"generated/hardi/","page":"High Angular Resolution","title":"High Angular Resolution","text":"Here we create a recipe for five stacked plates with isotropic diffusion tensors. They should allow for free diffusion in the horizontal direction, but a rather restricted vertical diffusion with the permeable membranes.","category":"page"},{"location":"generated/hardi/","page":"High Angular Resolution","title":"High Angular Resolution","text":"ncell = 5\nsetup = PlateSetup(;\n    name = \"Plates\",\n    width = 50.0,\n    depth = 50.0,\n    heights = fill(5.0, ncell),\n    bend = 0.0,\n    twist = 0.0,\n)\ncoeffs = coefficients(\n    setup;\n    D = [0.002 * I(3) for _ = 1:ncell],\n    T₂ = fill(Inf, ncell),\n    ρ = fill(1.0, ncell),\n    κ = (; interfaces = fill(1e-4, ncell - 1), boundaries = fill(0.0, ncell)),\n    γ = 2.67513e-4,\n)","category":"page"},{"location":"generated/hardi/","page":"High Angular Resolution","title":"High Angular Resolution","text":"We then proceed to build the geometry and finite element mesh.","category":"page"},{"location":"generated/hardi/","page":"High Angular Resolution","title":"High Angular Resolution","text":"mesh, = create_geometry(setup; recreate = true)\nplot_mesh(mesh)","category":"page"},{"location":"generated/hardi/","page":"High Angular Resolution","title":"High Angular Resolution","text":"The mesh looks good, so we may then proceed to assemble the biological model and the associated finite element matrices.","category":"page"},{"location":"generated/hardi/","page":"High Angular Resolution","title":"High Angular Resolution","text":"model = Model(; mesh, coeffs...)\nmatrices = assemble_matrices(model);\nnothing #hide","category":"page"},{"location":"generated/hardi/","page":"High Angular Resolution","title":"High Angular Resolution","text":"We may also compute some useful quantities, including a scalar diffusion coefficient from the diffusion tensors.","category":"page"},{"location":"generated/hardi/","page":"High Angular Resolution","title":"High Angular Resolution","text":"volumes = get_cmpt_volumes(model.mesh)\nD_avg = 1 / 3 * tr.(model.D)' * volumes / sum(volumes)\nncompartment = length(model.mesh.points)","category":"page"},{"location":"generated/hardi/","page":"High Angular Resolution","title":"High Angular Resolution","text":"The gradient pulse sequence will be a PGSE with both vertical and horizontal components. This allows for both restricted vertical diffusion and almost unrestricted horizontal diffusion. The different approaches should hopefully confirm this behaviour.","category":"page"},{"location":"generated/hardi/","page":"High Angular Resolution","title":"High Angular Resolution","text":"directions = unitsphere(200)\nprofile = PGSE(2500.0, 4000.0)\nb = 1000\ng = √(b / int_F²(profile)) / model.γ\ngradients = [ScalarGradient(d, profile, g) for d ∈ eachcol(directions)]","category":"page"},{"location":"generated/hardi/","page":"High Angular Resolution","title":"High Angular Resolution","text":"We may solve the BTPDE for each gradient.","category":"page"},{"location":"generated/hardi/","page":"High Angular Resolution","title":"High Angular Resolution","text":"btpde = BTPDE(; model, matrices)\nsolver = IntervalConstantSolver(; timestep = 10.0)\nξ, = solve_multigrad(btpde, gradients, solver)","category":"page"},{"location":"generated/hardi/","page":"High Angular Resolution","title":"High Angular Resolution","text":"The signals are computed from the magnetization field through quadrature.","category":"page"},{"location":"generated/hardi/","page":"High Angular Resolution","title":"High Angular Resolution","text":"signal = [abs(compute_signal(matrices.M, ξ)) for ξ ∈ ξ]","category":"page"},{"location":"generated/hardi/","page":"High Angular Resolution","title":"High Angular Resolution","text":"We may plot the directionalized signal.","category":"page"},{"location":"generated/hardi/","page":"High Angular Resolution","title":"High Angular Resolution","text":"plot_hardi(directions, signal)","category":"page"},{"location":"generated/hardi/","page":"High Angular Resolution","title":"High Angular Resolution","text":"The signal attenuates the most in the horizontal direction, as that is where diffusion is restricted the least.","category":"page"},{"location":"generated/hardi/","page":"High Angular Resolution","title":"High Angular Resolution","text":"","category":"page"},{"location":"generated/hardi/","page":"High Angular Resolution","title":"High Angular Resolution","text":"This page was generated using Literate.jl.","category":"page"},{"location":"theory/btpde/#Bloch-Torrey-partial-differential-equation","page":"Bloch-Torrey PDE","title":"Bloch-Torrey partial differential equation","text":"","category":"section"},{"location":"theory/btpde/","page":"Bloch-Torrey PDE","title":"Bloch-Torrey PDE","text":"In diffusion MRI, a time-varying magnetic field gradient vecg  0 T_textecho to mathbbR^3 is applied to the tissue to encode water diffusion. The resulting complex transverse water proton magnetization in the rotating frame satisfies the Bloch-Torrey PDE:","category":"page"},{"location":"theory/btpde/","page":"Bloch-Torrey PDE","title":"Bloch-Torrey PDE","text":"fracpartialpartial t M_i(vecxt) = -left(-nabla cdot mathbfD_i nabla +\nfrac1T_2i + underlinemathrmi gamma vecg(t) cdot vecxright)\nM_i(vecx t)","category":"page"},{"location":"theory/btpde/","page":"Bloch-Torrey PDE","title":"Bloch-Torrey PDE","text":"where","category":"page"},{"location":"theory/btpde/","page":"Bloch-Torrey PDE","title":"Bloch-Torrey PDE","text":"vecx in Omega_i,\nt in 0 T_textecho where T_textecho is the echo time at which the signal is measured,\ngamma = 267513times 10^8  mathrmrad  s^-1 T^-1 is the gyromagnetic ratio of the water proton,\nunderlinemathrmi is the imaginary unit,\nmathbfD_i is the intrinsic diffusion tensor in Omega_i,\nT_2i is the T_2-relaxation time in Omega_i, and\nM_i is the magnetization in Omega_i.","category":"page"},{"location":"theory/btpde/","page":"Bloch-Torrey PDE","title":"Bloch-Torrey PDE","text":"The initial conditions are given by","category":"page"},{"location":"theory/btpde/","page":"Bloch-Torrey PDE","title":"Bloch-Torrey PDE","text":"M_i(vecx 0) = rho_i in mathbbC quad i in 1 dots N_textcmpt","category":"page"},{"location":"theory/btpde/","page":"Bloch-Torrey PDE","title":"Bloch-Torrey PDE","text":"where rho_i is the initial spin density in Omega_i. The outer boundary conditions are given by","category":"page"},{"location":"theory/btpde/","page":"Bloch-Torrey PDE","title":"Bloch-Torrey PDE","text":"mathbfD_i nabla M_i(vecx t) cdot vecn_i(vecx) = -kappa_i M_i(vecx t)\nquad vecx in Gamma_i quad i in 1 dots N_textcmpt","category":"page"},{"location":"theory/btpde/","page":"Bloch-Torrey PDE","title":"Bloch-Torrey PDE","text":"and the interface conditions by","category":"page"},{"location":"theory/btpde/","page":"Bloch-Torrey PDE","title":"Bloch-Torrey PDE","text":"mathbfD_i nabla M_i(vecx t) cdot vecn_i(vecx) = -mathbfD_j nabla\nM_j(vecx t) cdot vecn_j(vecx) quad vecx in Gamma_i j quad (i j) in\n1 dots N_textcmpt^2","category":"page"},{"location":"theory/btpde/","page":"Bloch-Torrey PDE","title":"Bloch-Torrey PDE","text":"mathbfD_i nabla M_i(vecx t) cdot vecn_i(vecx) = kappa_i j left(c_i j\nM_j(vecx t) - c_j i M_i(vecx t)right) quad vecx in Gamma_i j quad (i\nj) in 1 dots N_textcmpt^2","category":"page"},{"location":"theory/btpde/","page":"Bloch-Torrey PDE","title":"Bloch-Torrey PDE","text":"where","category":"page"},{"location":"theory/btpde/","page":"Bloch-Torrey PDE","title":"Bloch-Torrey PDE","text":"vecn_i is the unit outward pointing normal vector of Omega_i\nkappa_i is a boundary relaxation coefficient for Omega_i,\nkappa_i j = kappa_j i is the permeability coefficient on Gamma_i j,\nc_i j and c_j i account for the spin density equilibrium between the two compartments, with either\nc_i j = c_j i = 1, in which case a uniform spin density across compartments is favored in the absence of a gradient, or\nc_i j = frac2 rho_irho_i + rho_j and c_j i = frac2 rho_jrho_i + rho_j, which ensures that the non-uniform intitial spin density is preserved in the absence of a gradient.","category":"page"},{"location":"theory/btpde/","page":"Bloch-Torrey PDE","title":"Bloch-Torrey PDE","text":"The diffusion MRI signal is measured at echo time t = T_textecho. This signal is computed as the spatial integral of the final magnetization M(cdot T_textecho):","category":"page"},{"location":"theory/btpde/","page":"Bloch-Torrey PDE","title":"Bloch-Torrey PDE","text":"S(vecg) = int_Omega M(vecx T_textecho)  mathrmd Omega(vecx)","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = SpinDoctor","category":"page"},{"location":"#SpinDoctor","page":"Home","title":"SpinDoctor","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This is the documentation for SpinDoctor, and is based on the SpinDoctor User Guide.","category":"page"},{"location":"","page":"Home","title":"Home","text":"SpinDoctor is a software package that performs numerical simulations of diffusion magnetic resonance imaging (dMRI) for prototyping purposes.","category":"page"},{"location":"","page":"Home","title":"Home","text":"SpinDoctor can be used","category":"page"},{"location":"","page":"Home","title":"Home","text":"to solve the Bloch-Torrey partial differential equation (BTDPE) to obtain the dMRI signal (the toolbox provides a way of robustly fitting the dMRI signal to obtain the fitted Apparent Diffusion Coefficient (ADC));\nto solve the diffusion equation for the homogenized ADC (HADC) model to obtain the ADC;\na short-time approximation formula for the ADC is also included in the toolbox for comparison with the simulated ADC;\nCompute the dMRI signal using a matrix formalism (MF) analytical solution based Laplace eigenfunctions.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The PDEs and Laplace eigenvalue decompositions are solved by P1 finite elements. The geometry recipes create surface triangulations that are passed to TetGen to perform the finite element mesh generation.","category":"page"},{"location":"","page":"Home","title":"Home","text":"SpinDoctor has support for the following features:","category":"page"},{"location":"","page":"Home","title":"Home","text":"multiple compartments connected through permeable membranes, with different\ninitial spin densities,\ndiffusion tensors,\nT2-relaxation, and\npermeability coefficients for the BTPDE and MF (the HADC assumes negligible permeability);\ndiffusion-encoding gradient pulse sequences, including\nthe pulsed gradient spin echo sequence (PGSE),\nthe double-PGSE,\nthe oscillating gradient spin echo (OGSE), and\ncustom three-dimensional pulse sequences vecg(t) = (g_x(t) g_y(t) g_z(t))^mathsfT;\nuniformly distributed gradient directions in 2D and 3D for high angular resolution diffusion imaging (HARDI).","category":"page"},{"location":"","page":"Home","title":"Home","text":"SpinDoctor also comes with a geometry generation module, allowing for","category":"page"},{"location":"","page":"Home","title":"Home","text":"spherical cells with a nucleus;\ncylindrical cells with a myelin layer;\nan extra-cellular space (ECS) enclosed in either a box, a convex hull, or a tight wrapping around the cells;\ndeformation of canonical cells by bending and twisting.","category":"page"},{"location":"","page":"Home","title":"Home","text":"In addition, a variety of neuron meshes is available, whose surface geometries were extracted from NeuroMopho.org. The neurons may also be enclosed in an extracellular space as described above.","category":"page"},{"location":"generated/compare_adcs/","page":"Compare ADCs","title":"Compare ADCs","text":"EditURL = \"https://github.com/SpinDoctorMRI/SpinDoctor.jl/blob/main/examples/compare_adcs.jl\"","category":"page"},{"location":"generated/compare_adcs/#Compare-ADCs","page":"Compare ADCs","title":"Compare ADCs","text":"","category":"section"},{"location":"generated/compare_adcs/","page":"Compare ADCs","title":"Compare ADCs","text":"The apparent diffusion coefficient (ADC) may be sufficient to describe the signal attenuation for small b-values. SpinDoctor comes with multiple approaches for computing or estimating the ADC for a ScalarGradient vecg(t) = f(t) g vecd:","category":"page"},{"location":"generated/compare_adcs/","page":"Compare ADCs","title":"Compare ADCs","text":"Using the free diffusion coefficient vecd^mathsfT mathbfD vecd, which represents unrestricted diffusion in the absence of boundaries;\nComputing the short diffusion time approximation for the ADC\nFitting the log-signal obtained by solving the BTPDE for different b-values\nSolving a homogenized model (HADC) assuming negligible permeability\nUsing the matrix formalism effective diffusion tensor","category":"page"},{"location":"generated/compare_adcs/","page":"Compare ADCs","title":"Compare ADCs","text":"In this example we will compare the different approaches.","category":"page"},{"location":"generated/compare_adcs/#Building-a-biological-model","page":"Compare ADCs","title":"Building a biological model","text":"","category":"section"},{"location":"generated/compare_adcs/","page":"Compare ADCs","title":"Compare ADCs","text":"We start by loading SpinDoctor and a Makie plotting backend.","category":"page"},{"location":"generated/compare_adcs/","page":"Compare ADCs","title":"Compare ADCs","text":"using SpinDoctor\nusing LinearAlgebra\n\nif haskey(ENV, \"GITHUB_ACTIONS\")\n    using CairoMakie\nelse\n    using GLMakie\nend","category":"page"},{"location":"generated/compare_adcs/","page":"Compare ADCs","title":"Compare ADCs","text":"Here we create a recipe for five stacked plates with isotropic diffusion tensors. They should allow for free diffusion in the horizontal direction, but a rather restricted vertical diffusion with the permeable membranes.","category":"page"},{"location":"generated/compare_adcs/","page":"Compare ADCs","title":"Compare ADCs","text":"ncell = 5\nsetup = PlateSetup(;\n    name = \"Plates\",\n    width = 50.0,\n    depth = 50.0,\n    heights = fill(5.0, ncell),\n    bend = 0.0,\n    twist = 0.0,\n    refinement = 10.0,\n)\ncoeffs = coefficients(\n    setup;\n    D = [0.002 * I(3) for _ = 1:ncell],\n    T₂ = fill(Inf, ncell),\n    ρ = fill(1.0, ncell),\n    κ = (; interfaces = fill(1e-4, ncell - 1), boundaries = fill(0.0, ncell)),\n    γ = 2.67513e-4,\n)","category":"page"},{"location":"generated/compare_adcs/","page":"Compare ADCs","title":"Compare ADCs","text":"We then proceed to build the geometry and finite element mesh.","category":"page"},{"location":"generated/compare_adcs/","page":"Compare ADCs","title":"Compare ADCs","text":"mesh, = create_geometry(setup; recreate = true)\nplot_mesh(mesh)","category":"page"},{"location":"generated/compare_adcs/","page":"Compare ADCs","title":"Compare ADCs","text":"The mesh looks good, so we may then proceed to assemble the biological model and the associated finite element matrices.","category":"page"},{"location":"generated/compare_adcs/","page":"Compare ADCs","title":"Compare ADCs","text":"model = Model(; mesh, coeffs...)\nmatrices = assemble_matrices(model);\nnothing #hide","category":"page"},{"location":"generated/compare_adcs/","page":"Compare ADCs","title":"Compare ADCs","text":"We may also compute some useful quantities, including a scalar diffusion coefficient from the diffusion tensors.","category":"page"},{"location":"generated/compare_adcs/","page":"Compare ADCs","title":"Compare ADCs","text":"volumes = get_cmpt_volumes(model.mesh)\nD_avg = 1 / 3 * tr.(model.D)' * volumes / sum(volumes)\nncompartment = length(model.mesh.points)","category":"page"},{"location":"generated/compare_adcs/","page":"Compare ADCs","title":"Compare ADCs","text":"The gradient pulse sequence will be a PGSE with both vertical and horizontal components. This allows for both restricted vertical diffusion and almost unrestricted horizontal diffusion. The different approaches should hopefully confirm this behaviour.","category":"page"},{"location":"generated/compare_adcs/","page":"Compare ADCs","title":"Compare ADCs","text":"dir = [1.0, 0.0, 1.0]\nprofile = PGSE(2500.0, 4000.0)\nb = 1000\ng = √(b / int_F²(profile)) / model.γ\ngradient = ScalarGradient(dir, profile, g)","category":"page"},{"location":"generated/compare_adcs/#Computing-the-ADC-using-different-methods","page":"Compare ADCs","title":"Computing the ADC using different methods","text":"","category":"section"},{"location":"generated/compare_adcs/#Short-term-approximation","page":"Compare ADCs","title":"Short term approximation","text":"","category":"section"},{"location":"generated/compare_adcs/","page":"Compare ADCs","title":"Compare ADCs","text":"A simple model for the ADC is given by the short term approximation.","category":"page"},{"location":"generated/compare_adcs/","page":"Compare ADCs","title":"Compare ADCs","text":"adc_sta_cmpts = compute_adc_sta(model, gradient)\nadc_sta = volumes'adc_sta_cmpts / sum(volumes)","category":"page"},{"location":"generated/compare_adcs/#Fitting-the-ADC","page":"Compare ADCs","title":"Fitting the ADC","text":"","category":"section"},{"location":"generated/compare_adcs/","page":"Compare ADCs","title":"Compare ADCs","text":"A more robust approach is to directly fit the BTPDE signal to a series of b-values. This is however more computationally expensive. We start by building a set of gradients.","category":"page"},{"location":"generated/compare_adcs/","page":"Compare ADCs","title":"Compare ADCs","text":"bvalues = 0:400:4000\ngvalues = map(b -> √(b / int_F²(profile)) / coeffs.γ, bvalues)\ngradients = [ScalarGradient(gradient.dir, gradient.profile, g) for g ∈ gvalues]","category":"page"},{"location":"generated/compare_adcs/","page":"Compare ADCs","title":"Compare ADCs","text":"The solve_multigrad function computes the magnetization for each gradient. Since the gradients are interval-wise constant, we can use a specialized solver.","category":"page"},{"location":"generated/compare_adcs/","page":"Compare ADCs","title":"Compare ADCs","text":"btpde = BTPDE(; model, matrices)\nsolver = IntervalConstantSolver(; θ = 0.5, timestep = 5.0)\nξ, = solve_multigrad(btpde, gradients, solver)","category":"page"},{"location":"generated/compare_adcs/","page":"Compare ADCs","title":"Compare ADCs","text":"The signals can be computed from the magnetization fields.","category":"page"},{"location":"generated/compare_adcs/","page":"Compare ADCs","title":"Compare ADCs","text":"signals = [compute_signal(matrices.M, ξ) for ξ ∈ ξ]\nsignals_cmpts = [compute_signal.(matrices.M_cmpts, split_field(model.mesh, ξ)) for ξ ∈ ξ]","category":"page"},{"location":"generated/compare_adcs/","page":"Compare ADCs","title":"Compare ADCs","text":"Fitting the ADC is straightforward.","category":"page"},{"location":"generated/compare_adcs/","page":"Compare ADCs","title":"Compare ADCs","text":"adc_fit = fit_adc(bvalues, signals)\nadc_fit_cmpts =\n    [fit_adc(bvalues, [s[icmpt] for s ∈ signals_cmpts]) for icmpt = 1:ncompartment]","category":"page"},{"location":"generated/compare_adcs/#Homogenized-ADC-model","page":"Compare ADCs","title":"Homogenized ADC model","text":"","category":"section"},{"location":"generated/compare_adcs/","page":"Compare ADCs","title":"Compare ADCs","text":"The HADC-model uses homogenization and assumes negligible permeability between the compartments. This does require solving an ODE involving all the degrees of freedom.","category":"page"},{"location":"generated/compare_adcs/","page":"Compare ADCs","title":"Compare ADCs","text":"hadc = HADC(; model, matrices)\nadc_homogenized_cmpts = solve(hadc, gradient)\nadc_homogenized = volumes'adc_homogenized_cmpts / sum(volumes)","category":"page"},{"location":"generated/compare_adcs/#Matrix-Formalism","page":"Compare ADCs","title":"Matrix Formalism","text":"","category":"section"},{"location":"generated/compare_adcs/","page":"Compare ADCs","title":"Compare ADCs","text":"If a Laplace eigendecomposition is available, the HADC can be approximated with little additional computational expense.","category":"page"},{"location":"generated/compare_adcs/","page":"Compare ADCs","title":"Compare ADCs","text":"laplace = Laplace(; model, matrices, neig_max = 400)\nlap_eig = solve(laplace)","category":"page"},{"location":"generated/compare_adcs/","page":"Compare ADCs","title":"Compare ADCs","text":"An effective diffusion tensor can be computed.","category":"page"},{"location":"generated/compare_adcs/","page":"Compare ADCs","title":"Compare ADCs","text":"D_mf = compute_mf_diffusion_tensor(model.mesh, matrices.M, lap_eig, gradient)","category":"page"},{"location":"generated/compare_adcs/","page":"Compare ADCs","title":"Compare ADCs","text":"We observe that D_x x and D_y y are very close to the intrinsic diffusion coefficient D = 0002, which confirms that diffusion in the horizontal direction is almost unrestricted. D_z z is significantly smaller, confirming the presence of membranes along the vertical direction.","category":"page"},{"location":"generated/compare_adcs/","page":"Compare ADCs","title":"Compare ADCs","text":"In particular, we may deduce the MF-ADC in our direction.","category":"page"},{"location":"generated/compare_adcs/","page":"Compare ADCs","title":"Compare ADCs","text":"adc_mf = dir'D_mf * dir / dir'dir","category":"page"},{"location":"generated/compare_adcs/#Comparing-results","page":"Compare ADCs","title":"Comparing results","text":"","category":"section"},{"location":"generated/compare_adcs/#Compartment-ADCs","page":"Compare ADCs","title":"Compartment ADCs","text":"","category":"section"},{"location":"generated/compare_adcs/","page":"Compare ADCs","title":"Compare ADCs","text":"Here we make a comparison between the compartment ADCs. For MF, only a global ADC was computed.","category":"page"},{"location":"generated/compare_adcs/","page":"Compare ADCs","title":"Compare ADCs","text":"n = ncompartment\nfig = Figure()\nax = Axis(fig[1, 1];\n    xticks = (1:4, [\"STA\", \"Fit BTPDE\", \"HADC\", \"MF\"]),\n    ylabel = \"ADC / D\",\n    title = \"Compartment ADCs\",\n)\nbarplot!(ax, fill(1, n), adc_sta_cmpts ./ D_avg; dodge = 1:n)\nbarplot!(ax, fill(2, n), adc_fit_cmpts ./ D_avg; dodge = 1:n)\nbarplot!(ax, fill(3, n), adc_homogenized_cmpts ./ D_avg; dodge = 1:n)\nbarplot!(ax, [4], [adc_mf / D_avg])\nfig","category":"page"},{"location":"generated/compare_adcs/","page":"Compare ADCs","title":"Compare ADCs","text":"The STA and HADC are the same for all compartments, as they consider them separately and all the compartments have the same size. The fitted ADC is larger for the three inner compartments, as they all have permeable membranes both below and above, in contrast to the top and bottom compartments that have hard walls.","category":"page"},{"location":"generated/compare_adcs/#Signal-attenuation","page":"Compare ADCs","title":"Signal attenuation","text":"","category":"section"},{"location":"generated/compare_adcs/","page":"Compare ADCs","title":"Compare ADCs","text":"We may also inspect the resulting signal attenuations.","category":"page"},{"location":"generated/compare_adcs/","page":"Compare ADCs","title":"Compare ADCs","text":"fig = Figure()\nax = Axis(fig[1,1]; xlabel = \"b\", yscale = log10, title = \"Signal attenuation\")\nlines!(ax, [0, bvalues[end]], [1, exp(-adc_sta * bvalues[end])]; linestyle = :dash, label = \"ADC STA\")\nlines!(ax, [0, bvalues[end]], [1, exp(-adc_fit * bvalues[end])]; linestyle = :dash, label = \"ADC Fit\")\nlines!(ax, [0, bvalues[end]], [1, exp(-adc_homogenized * bvalues[end])]; linestyle = :dash, label = \"HADC\")\nlines!(ax, [0, bvalues[end]], [1, exp(-adc_mf * bvalues[end])]; linestyle = :dash, label = \"ADC MF\")\nlines!(ax, [0, bvalues[end]], [1, exp(-D_avg * bvalues[end])]; linestyle = :dash, label = \"Free diffusion\")\nscatterlines!(ax, bvalues, abs.(signals) ./ abs(signals[1]); label = \"BTPDE Signal\")\naxislegend(ax)\nfig","category":"page"},{"location":"generated/compare_adcs/","page":"Compare ADCs","title":"Compare ADCs","text":"We observe the following:","category":"page"},{"location":"generated/compare_adcs/","page":"Compare ADCs","title":"Compare ADCs","text":"The exact signal starts to visually deviate from the log-linear regime after b = 2000. For higher b-values, the ADC is no longer sufficient to describe the attenuation, as higher order terms can no longer be neglected.\nThe fit-ADC signal coincides with the exact signal for the lowest b-values. This makes sense since that is how this ADC was obtained to begin with. This is considered to be the \"reference\" ADC.\nThe free diffusion signal attenuates more thant the exact signal by many orders of magnitude, which confirms the presence of restrictive membranes and boundaries in the gradient direction.\nThe HADC signal attenuates less than the exact signal, as it assumes a more severe restriction with impermeable membranes.\nThe MF-ADC signal coincides with the HADC signal, as the former is simply an MF approximation of the latter.","category":"page"},{"location":"generated/compare_adcs/","page":"Compare ADCs","title":"Compare ADCs","text":"","category":"page"},{"location":"generated/compare_adcs/","page":"Compare ADCs","title":"Compare ADCs","text":"This page was generated using Literate.jl.","category":"page"}]
}
