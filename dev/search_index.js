var documenterSearchIndex = {"docs":
[{"location":"examples/compute_adc/#Compare-ADCs","page":"Compare ADCs","title":"Compare ADCs","text":"","category":"section"},{"location":"examples/compute_adc/","page":"Compare ADCs","title":"Compare ADCs","text":"SpinDoctor comes with multiple approaches for computing the apparent diffusion coefficient (ADC) for a ScalarGradient vecg(t) = f(t) g vecd:","category":"page"},{"location":"examples/compute_adc/","page":"Compare ADCs","title":"Compare ADCs","text":"The free diffusion coefficient fracvecd D vecdvecd vecd, which   represents unrestricted diffusion in the absence of boundaries\nComputing the short diffusion time approximation for the ADC\nFitting the signal obtained by solving the BTPDE for different b-values\nSolving a homogenized model (HADC)\nUsing the matrix formalism effective diffusion tensor","category":"page"},{"location":"examples/compute_adc/","page":"Compare ADCs","title":"Compare ADCs","text":"In this example we will compare the different approaches for a mesh.","category":"page"},{"location":"examples/compute_adc/","page":"Compare ADCs","title":"Compare ADCs","text":"using SpinDoctor","category":"page"},{"location":"neurons/#Neurons","page":"Neurons","title":"Neurons","text":"","category":"section"},{"location":"neurons/","page":"Neurons","title":"Neurons","text":"NeuroMopho.org.","category":"page"},{"location":"neurons/","page":"Neurons","title":"Neurons","text":"Table","category":"page"},{"location":"examples/solve_btpde/#Solve-BTPDE","page":"Solve BTPDE","title":"Solve BTPDE","text":"","category":"section"},{"location":"examples/solve_btpde/","page":"Solve BTPDE","title":"Solve BTPDE","text":"We start by loading SpinDoctor.","category":"page"},{"location":"examples/solve_btpde/","page":"Solve BTPDE","title":"Solve BTPDE","text":"using LinearAlgebra\nusing SpinDoctor","category":"page"},{"location":"examples/solve_btpde/","page":"Solve BTPDE","title":"Solve BTPDE","text":"The built in geometry recipes allow for making various cell configuration. We here consider the case of twisted axons immersed in an extracellular space (ECS).","category":"page"},{"location":"examples/solve_btpde/","page":"Solve BTPDE","title":"Solve BTPDE","text":"setup = CylinderSetup(;\n    name = \"some-very-real-axons\",\n    ncell = 3,\n    rmin = 2.0,\n    rmax = 6.0,\n    dmin = 0.2,\n    dmax = 0.3,\n    height = 10.0,\n    bend = 0.0,\n    twist = π / 4,\n    include_in = false,\n    in_ratio = 0.6,\n    ecs_shape = :convex_hull,\n    ecs_ratio = 0.5,\n)","category":"page"},{"location":"examples/solve_btpde/","page":"Solve BTPDE","title":"Solve BTPDE","text":"We also define coefficients for the different cell compartments :in (axon), :out (myelin), and :ecs (ECS).","category":"page"},{"location":"examples/solve_btpde/","page":"Solve BTPDE","title":"Solve BTPDE","text":"coeffs = coefficients(\n    setup;\n    D = (; in = 0.002 * I(3), out = 0.002 * I(3), ecs = 0.002 * I(3)),\n    T₂ = (; in = Inf, out = Inf, ecs = Inf),\n    ρ = (; in = 1.0, out = 1.0, ecs = 1.0),\n    κ = (; in_out = 1e-4, out_ecs = 1e-4, in = 0.0, out = 0.0, ecs = 0.0),\n    γ = 2.67513e-4,\n)","category":"page"},{"location":"examples/solve_btpde/","page":"Solve BTPDE","title":"Solve BTPDE","text":"The following line creates a random cell configuration for our cylinder setup, generates a surface triangulation and calls TetGen to create a tetrahedral finite element mesh. The compartments and boundaries will be ordered in the same way as coeffs.","category":"page"},{"location":"examples/solve_btpde/","page":"Solve BTPDE","title":"Solve BTPDE","text":"mesh, = create_geometry(setup)","category":"page"},{"location":"examples/solve_btpde/","page":"Solve BTPDE","title":"Solve BTPDE","text":"The resulting mesh can be plotted in 3D provided the GLMakie backend is loaded.","category":"page"},{"location":"examples/solve_btpde/","page":"Solve BTPDE","title":"Solve BTPDE","text":"using GLMakie\nplot_mesh(mesh)","category":"page"},{"location":"examples/solve_btpde/","page":"Solve BTPDE","title":"Solve BTPDE","text":"The mesh looks good, so we can proceed with the assembly our biological model and the associated finite element matrices.","category":"page"},{"location":"examples/solve_btpde/","page":"Solve BTPDE","title":"Solve BTPDE","text":"model = Model(; mesh, coeffs...)\nmatrices = assemble_matrices(model)","category":"page"},{"location":"examples/solve_btpde/","page":"Solve BTPDE","title":"Solve BTPDE","text":"The Bloch-Torrey PDE takes a magnetic field gradient pulse sequence as an input. We may define our gradient (given in T/m) and echo time TE (given in microseconds) as follows:","category":"page"},{"location":"examples/solve_btpde/","page":"Solve BTPDE","title":"Solve BTPDE","text":"TE = 5000.0\ng⃗(t) = 0.5 * [sin(10π * t / TE), 0, 0]\ngradient = GeneralGradient(g⃗, TE)","category":"page"},{"location":"examples/solve_btpde/","page":"Solve BTPDE","title":"Solve BTPDE","text":"SpinDoctor provides a solve function, which has the same base signature for all diffusion MRI problems. The BTPDE is one such problem. They generally take a gradient sequence as an input.","category":"page"},{"location":"examples/solve_btpde/","page":"Solve BTPDE","title":"Solve BTPDE","text":"btpde = GeneralBTPDE(; model, mesh)\nξ = solve(btpde, gradient)","category":"page"},{"location":"examples/solve_btpde/","page":"Solve BTPDE","title":"Solve BTPDE","text":"Here, ξ is a vector containing the complex-valued magnetization at all degrees of freedom at the echo time TE. We may compute the resulting signal as follows:","category":"page"},{"location":"examples/solve_btpde/","page":"Solve BTPDE","title":"Solve BTPDE","text":"compute_signal(matrices.M, ξ)","category":"page"},{"location":"examples/solve_btpde/","page":"Solve BTPDE","title":"Solve BTPDE","text":"The global mass matrix M is used to compute the integral. We may however be interested in the compartment-wise signals. This requires splitting the magnetization field into the respective compartments. The compartment mass matrices are also available.","category":"page"},{"location":"examples/solve_btpde/","page":"Solve BTPDE","title":"Solve BTPDE","text":"ξ_cmpts = split_field(mesh, ξ)\ncompute_signal.(matrices.M_cmpts, ξ_cmpts)","category":"page"},{"location":"examples/solve_btpde/","page":"Solve BTPDE","title":"Solve BTPDE","text":"The final magnetization can be visualized using the plot_field function.","category":"page"},{"location":"examples/solve_btpde/","page":"Solve BTPDE","title":"Solve BTPDE","text":"plot_field(mesh, ξ)","category":"page"},{"location":"theory/matrix_formalism/#Matrix-formalism","page":"Matrix Formalism","title":"Matrix formalism","text":"","category":"section"},{"location":"theory/definitions/#Definitions","page":"Definitions","title":"Definitions","text":"","category":"section"},{"location":"theory/definitions/#Abbreviations","page":"Definitions","title":"Abbreviations","text":"","category":"section"},{"location":"theory/definitions/","page":"Definitions","title":"Definitions","text":"ADC, Apparent Diffusion Coefficient;\nBT, Bloch-Torrey;\nBTPDE, Bloch-Torrey PDE;\nDMRI, Diffusion MRI;\nECS, Extra-Cellular Space;\nFEM, Finite Element Method;\nHADC, Homogenized ADC model;\nHARDI, High Angular Resolution Diffusion Imaging;\nMF, Matrix Formalism;\nMRI, Magnetic Resonance Imaging;\nODE, Ordinary Differential Equation;\nOGSE, Oscillating Gradient Spin Echo sequence;\nPDE, Partial Differential Equation;\nPGSE, Pulsed-Gradient Spin Echo sequence;\nSTA, Short Time Approximation.","category":"page"},{"location":"theory/definitions/#Geometrical-configuration","page":"Definitions","title":"Geometrical configuration","text":"","category":"section"},{"location":"theory/definitions/","page":"Definitions","title":"Definitions","text":"In SpinDoctor, we consider a domain Omega = bigcup_i = 1^N_textcmpt Omega_i subset mathbbR^3 consisting of N_textcmpt compartments Omega_i_1 leq i leq N_textcmpt. The permeable interface between two compartments is denoted by Gamma_i j = Omega_i cap Omega_j for i neq j, (i j) in 1 dots N_textcmpt^2. For i = j, we let Gamma_ii = emptyset for the ease of notation. Finally, let partial Omega denote the outer boundary of the domain, and Gamma_i = Omega_i cap partial Omega its restriction to Omega_i. Note that for compartments that do not touch, we have Gamma_i j = emptyset. Similarly, we have Gamma_i = emptyset for compartments that do not touch the outer boundary.","category":"page"},{"location":"theory/discretization/#Finite-element-discretization","page":"Discretization","title":"Finite element discretization","text":"","category":"section"},{"location":"theory/discretization/","page":"Discretization","title":"Discretization","text":"In SpinDoctor, the finite element mesh generation is performed using an external package called Tetgen. Each finite element mesh consists of","category":"page"},{"location":"theory/discretization/","page":"Discretization","title":"Discretization","text":"a list of N_textnode nodes in three dimensions: (mathbfq_1 dots mathbfq_N_textnode) = (mathbfq^x mathbfq^y mathbfq^z)^mathsfT in R^3 times N_textnode;\na list of N_textelement tetrahedral elements (4 times N_textelement indices referencing the nodes).","category":"page"},{"location":"theory/discretization/","page":"Discretization","title":"Discretization","text":"The list of nodes includes double nodes that are placed at the interfaces between compartments connected by permeable membranes. This allows for representing discontinuous magnetization fields M_i and M_j (or phi^i and phi^j) on the same boundary Gamma_i j. To distinguish between the different compartments, let 1 dots N_textnode = bigcup_i = 1^N_textcmpt mathcalI_i with mathcalI_i cap mathcalI_j = emptyset for i neq j. The set mathcalI_i contains the indices of the nodes representing compartment Omega_i, including interface nodes.  In the adjacent compartments, the corresponding interface nodes will have different indices, distinct from mathcalI_i.","category":"page"},{"location":"theory/discretization/","page":"Discretization","title":"Discretization","text":"In SpinDoctor, the finite element space is the space of compartment-wise continuous piecewise linear functions on tetrahedral elements in three dimensions. This space has a set of basis functions whose number is exactly the number of finite element nodes (including double nodes), and that are defined on the entire domain Omega:","category":"page"},{"location":"theory/discretization/","page":"Discretization","title":"Discretization","text":"varphi_k  Omega to 0 1 quad k in 1 dots N_textnode","category":"page"},{"location":"theory/discretization/","page":"Discretization","title":"Discretization","text":"Let the finite element nodes be denoted by mathbfq_1 dots mathbfq_N_textnode. The basis function varphi_k, k in mathcalI_i, is a piece-wise linear function, non-zero on the tetrahedra of Omega_i that touch the node mathbfq_k, and zero on all other tetrahedra (including tetrahedra of other compartments different than Omega_i that do touch mathbfq_k). At the interface Gamma_i j between two compartments, the value of varphi_k is set to be the value it has inside its own compartment, distinct from that of the adjacent compartment. On a tetrahedron of Omega_i that touches mathbfq_k, varphi_k is equal to 1 on mathbfq_k and it is equal to 0 on the other 3 vertices of the tetrahedron. This completely describes the piece-wise linear function. The index sets may then be defined by mathcalI_i = k = 1 dots N_textnode    operatornamesupp (varphi_k) subset Omega_i, the set of indices of the finite element nodal functions whose supports lie entirely within Omega_i.","category":"page"},{"location":"theory/discretization/","page":"Discretization","title":"Discretization","text":"Any function u in the finite element space can be written as a linear combination of the above basis functions:","category":"page"},{"location":"theory/discretization/","page":"Discretization","title":"Discretization","text":"u(vecx) = sum_k = 1^N_textnode alpha_k varphi_k(vecx) =\nbmalpha^mathsfT bmvarphi(vecx) ","category":"page"},{"location":"theory/discretization/","page":"Discretization","title":"Discretization","text":"where bmalpha = (alpha_1 dots alpha_N_textnode)^mathsfT is the vector of coefficients and bmvarphi = (varphi_1 dots varphi_N_textnode)^mathsfT is the vector of finite element nodal basis functions.","category":"page"},{"location":"theory/discretization/","page":"Discretization","title":"Discretization","text":"To discretize the Bloch-Torrey and Laplace operators, we construct the following finite element matrices: mathbfMmathbfSmathbfQinR^N_textnodetimes N_textnode, known in the FEM literature as the mass, stiffness, and flux matrices, respectively. These matrices matrices we need are defined as follows, for (k l) in 1 dots N_textnode:","category":"page"},{"location":"theory/discretization/","page":"Discretization","title":"Discretization","text":"M_kl = int_Omega varphi_k(vecx) varphi_l(vecx)  mathrmd\nOmega(vecx)","category":"page"},{"location":"theory/discretization/","page":"Discretization","title":"Discretization","text":"S_kl = int_Omega mathbfD(vecx) nabla varphi_k(vecx) cdot nabla\nvarphi_l(vecx)  mathrmd Omega(vecx)","category":"page"},{"location":"theory/discretization/","page":"Discretization","title":"Discretization","text":"Q_kl = sum_i = 1^N_textcmpt Q_kl^i + sum_i = 1^N_textcmpt sum_j =\n1^N_textcmpt Q_kl^i j","category":"page"},{"location":"theory/discretization/","page":"Discretization","title":"Discretization","text":"the latter being defined as the sum of interface integrals:","category":"page"},{"location":"theory/discretization/","page":"Discretization","title":"Discretization","text":"Q_kl^i = kappa_i int_Gamma_i varphi_k(vecx) varphi_l(vecx)  mathrmd\nGamma(vecx) quad i in 1 dots N_textcmpt","category":"page"},{"location":"theory/discretization/","page":"Discretization","title":"Discretization","text":"Q_kl^i j =\nbegincases\n    kappa_i j c_j i int_Gamma_i j varphi_k(vecx) varphi_l(vecx) \n    mathrmd Gamma(vecx) quad   (k l) in mathcalI_i^2 \n    -kappa_i j c_i j int_Gamma_i j varphi_k(vecx) varphi_l(vecx) \n    mathrmd Gamma(vecx) quad  (k l) in mathcalI_i times mathcalI_j \n    0 quad  textotherwise\nendcases\nquad (i j) in 1 dots N_textcmpt^2","category":"page"},{"location":"theory/discretization/","page":"Discretization","title":"Discretization","text":"We remind the reader that i and j are compartment indices, while k and l are finite element nodal indices. Note that the above sum formulation counts each interface twice, but only considers the contribution to one side of the boundary at the time. It also correctly accounts for corner nodes (if any) that belong to two different permeable boundaries at the same time.","category":"page"},{"location":"theory/discretization/","page":"Discretization","title":"Discretization","text":"The weak form of the Bloch-Torrey PDE also requires computing the first order moments of the product of pairs of finite element basis functions. We let these three matrices be denoted by mathbfJ^x, mathbfJ^y and mathbfJ^z:","category":"page"},{"location":"theory/discretization/","page":"Discretization","title":"Discretization","text":"J_k l^x = int_Omega x  varphi_k(vecx) varphi_l(vecx)  mathrmd\nOmega(vecx) quad (k l) in 1 dots N_textnode^2","category":"page"},{"location":"theory/discretization/","page":"Discretization","title":"Discretization","text":"J_k l^y = int_Omega y  varphi_k(vecx) varphi_l(vecx)  mathrmd\nOmega(vecx) quad (k l) in 1 dots N_textnode^2","category":"page"},{"location":"theory/discretization/","page":"Discretization","title":"Discretization","text":"J_k l^z = int_Omega z  varphi_k(vecx) varphi_l(vecx)  mathrmd\nOmega(vecx) quad (k l) in 1 dots N_textnode^2","category":"page"},{"location":"theory/discretization/","page":"Discretization","title":"Discretization","text":"where vecx = (x y z)^mathsfT. For a given gradient vector vecg = (g_x g_y g_z)^mathsfT, we define","category":"page"},{"location":"theory/discretization/","page":"Discretization","title":"Discretization","text":"mathbfJ(vecg) = g_x mathbfJ^x + g_y mathbfJ^y + g_z mathbfJ^z","category":"page"},{"location":"theory/discretization/","page":"Discretization","title":"Discretization","text":"In addition, we define the finite element relaxation matrix mathbfR in mathbbR^N_textnode times N_textnode given by","category":"page"},{"location":"theory/discretization/","page":"Discretization","title":"Discretization","text":"R_kl = int_Omega frac1T_2(vecx)  varphi_k(vecx) varphi_l(vecx) \nmathrmd Omega(vecx) quad (k l) in 1 dots N_textnode^2","category":"page"},{"location":"theory/discretization/","page":"Discretization","title":"Discretization","text":"In SpinDoctor, these matrices are assembled from local element matrices and the assembly process is based on vectorized routines of, which replace expensive loops over elements by operations with 3-dimensional arrays. All local element matrices in the assembly of mathbfS, mathbfM, and mathbfQ are evaluated at the same time and stored in a full matrix of size 4 times 4 times N_textelement, where N_textelement denotes the number of tetrahedral elements.","category":"page"},{"location":"theory/discretization/","page":"Discretization","title":"Discretization","text":"The matrices mathbfJ^x, mathbfJ^y, and mathbfJ^z are assembled as coordinate weighted mass matrices, where the three coordinate functions vecx mapsto x, y, z act as nodal weights in the assembly process, given by mathbfq^x, mathbfq^y, mathbfq^z; the vectors of x, y, and z coordinates of the finite element nodes.","category":"page"},{"location":"theory/discretization/","page":"Discretization","title":"Discretization","text":"With compartment-wise constant T_2-relaxation times, \\mathbf{R} is a block-diagonally scaled version of the mass matrix \\mathbf{M}, where the weights are the inverses of the relaxation times.","category":"page"},{"location":"theory/discretization/#Finite-element-solution-to-the-Bloch-Torrey-PDE","page":"Discretization","title":"Finite element solution to the Bloch-Torrey PDE","text":"","category":"section"},{"location":"theory/discretization/","page":"Discretization","title":"Discretization","text":"The solution to the Bloch-Torrey partial differential equation \\eqref{eq:btpde} may be projected onto the finite element nodal basis (varphi_k)_1leq kleq N_textnode, in which case it is given by","category":"page"},{"location":"theory/discretization/","page":"Discretization","title":"Discretization","text":"M(vecxt) = sum_k = 1^N_textnode\nxi_k(t)varphi_k(vecx) = bmxi^mathsfT(t) bmvarphi(vecx)","category":"page"},{"location":"theory/discretization/","page":"Discretization","title":"Discretization","text":"where bmvarphi = (varphi_1dotsvarphi_N_textnode)^mathsfT in mathbbR^N_textnode is the vector of finite element basis functions and the function bmxi = (xi_1 dots xi_N_textnode)^mathsfT  0 T_textecho to mathbbC^N_textnode is the solution to the following system of ordinary differential equations (ODE):","category":"page"},{"location":"theory/discretization/","page":"Discretization","title":"Discretization","text":"mathbfM fracmathrmd bmximathrmd t = -left(mathbfS + mathbfQ + mathbfR +\nunderlinemathrmi gamma f(t) mathbfJ(vecg)right)bmxi(t)","category":"page"},{"location":"theory/discretization/","page":"Discretization","title":"Discretization","text":"We note that the notation ^mathsfT in Eq. \\eqref{eq:btpdesolutionfe} only denotes the transpose, as opposed to the complex conjugate transpose ^*. The complex transverse water proton magnetization M and thus its coefficients bmxi may contain complex values. This is not the case for the finite element basis functions bmvarphi, which are real-valued.","category":"page"},{"location":"theory/discretization/#Finite-element-solution-to-the-HADC-model","page":"Discretization","title":"Finite element solution to the HADC model","text":"","category":"section"},{"location":"theory/discretization/","page":"Discretization","title":"Discretization","text":"Similarly, the solution to the HADC model \\eqref{eq:hadc_pde}, omega, may be obtained by solving the equation","category":"page"},{"location":"theory/discretization/","page":"Discretization","title":"Discretization","text":"mathbfM fracmathrmd bmzetamathrmd t = - mathbfS bmzeta(t) + F(t)\nmathbfG mathbfD vecd","category":"page"},{"location":"theory/discretization/","page":"Discretization","title":"Discretization","text":"where bmzeta = (zeta_1 dots zeta_N_textnode)  0 T_textecho to mathbbR^N_textnode is the unknown vector of coefficients of the solution omega(vecx t) = bmzeta^mathsfT(t) bmvarphi(vecx), bmvarphi = (varphi_1 dots varphi_N_textnode) is the vector of finite element basis functions, and mathbfG in mathbbR^N_textnode times 3 is given by","category":"page"},{"location":"theory/discretization/","page":"Discretization","title":"Discretization","text":"mathbfG = sum_k = 1^N_textnode int_partial Omega varphi_k(vecx)\nbmvarphi(vecx) vecn^mathsfT(vecx)  mathrmdGamma(vecx)","category":"page"},{"location":"theory/discretization/","page":"Discretization","title":"Discretization","text":"where vecn = (n_x n_y n_z)^mathsfT is the outwards unit normal. This three-column matrix represents the components of the boundary integral of the quantity F(t) vecd^mathsfT mathbfD vecn, where the constant diffusivity and gradient sequence dependent part F(t) vecd^mathsfT mathbfD has been factored out. They can thus be assembled independently of the gradient sequence, and be reused when solving for multiple sequences or directions. They are assembled using the same routine as for \\mathbf{Q}.","category":"page"},{"location":"theory/discretization/","page":"Discretization","title":"Discretization","text":"The boundary integral h from Eq. \\eqref{eq:hadchdef} is then given by","category":"page"},{"location":"theory/discretization/","page":"Discretization","title":"Discretization","text":"h(t) = frac1Omega bmzeta^mathsfT(t) mathbfG vecd","category":"page"},{"location":"theory/discretization/","page":"Discretization","title":"Discretization","text":"where Omega = sum_jk = 1^N_textnode M_jk is computed using the mass matrix.","category":"page"},{"location":"theory/discretization/#Finite-element-Matrix-Formalism-signal-representation","page":"Discretization","title":"Finite element Matrix Formalism signal representation","text":"","category":"section"},{"location":"theory/discretization/","page":"Discretization","title":"Discretization","text":"Both of the above ODEs are of dimension N_textnode, the number of finite element nodes. The finite element discretized Matrix Formalism representation uses a different approach, limiting the problem size to N_texteig, the number of Laplace eigenfunctions (of which the choice is further explored in section. But first we need to solve an eigenvalue problem involving matrices of size N_textnodetimes N_textnode. The finite element discretization changes the continuous Laplace operator eigenvalue problem into the following discrete, generalized matrix eigenvalue problem: find (lambda mathbfp) in mathbbR times mathbbR^N_textnode such that","category":"page"},{"location":"theory/discretization/","page":"Discretization","title":"Discretization","text":"lambda mathbfM mathbfp = (mathbfS + mathbfQ) mathbfp","category":"page"},{"location":"theory/discretization/","page":"Discretization","title":"Discretization","text":"of which we will retain the N_texteig smallest eigenvalues and corresponding eigenvectors (lambda_n mathbfp_n)_1 leq n leq N_texteig, with N_texteig leq N_textnode. Note however that there are in total N_textnode solutions to the problem \\eqref{eq:matrixeig}. Moving back to the space of functions (the function space P_1), the eigenfunction phi_n(vecx) associated to the eigenvalue lambda_n is then","category":"page"},{"location":"theory/discretization/","page":"Discretization","title":"Discretization","text":"phi_n(vecx) = sum_k = 1^N_textnode p_n^k varphi_k(vecx) =\nmathbfp_n^mathsfT bmvarphi(vecx) quad n in 1 dots N_texteig","category":"page"},{"location":"theory/discretization/","page":"Discretization","title":"Discretization","text":"where the entries of the eigenvector mathbfp_n are the coefficients of the eigenfunction phi_n in the finite element basis. Using matrix notation, this conversion can also be written bmphi = mathbfP^mathsfT bmvarphi, where bmvarphi = (varphi_1 dots varphi_N_textnode)^mathsfT, bmphi = (phi_1 dots phi_N_texteig)^mathsfT, and mathbfP = (mathbfp_1 dots mathbfp_N_texteig) in mathbbR^N_textnode times N_texteig. The integrals of the finite element discretized eigenfunctions are then given by bmPhi = int_Omega bmphi(vecx)  mathrmd Omega(vecx) = mathbfP^mathsfT mathbfM mathbfo, where mathbfo = (1 dots 1)^mathsfT in mathbbR^N_textnode. Similarly, the coefficients of the initial spin density in the finite element discretized eigenfunction basis are given by bmnu = int_Omega rho(vecx) bmphi(vecx)  mathrmd Omega(vecx) = mathbfP^mathsfT mathbfM bmrho, where bmrho = (rho_i(k))_1 leq k leq N_textnode in mathbbR^N_textnode and i(k) in 1 dots N_textcmpt is such that k in mathcalI_i(k).","category":"page"},{"location":"theory/discretization/","page":"Discretization","title":"Discretization","text":"Then it is clear that the first order moments of the product of pairs of Laplace eigenfunctions can be written as:","category":"page"},{"location":"theory/discretization/","page":"Discretization","title":"Discretization","text":"mathbfA^u = mathbfP^mathsfTmathbfJ^umathbfP quad u = x y z","category":"page"},{"location":"theory/discretization/","page":"Discretization","title":"Discretization","text":"These three matrices are computed using a total of six matrix-matrix multiplications. Similarly, the eigenfunction basis relaxation matrix \\mathbf{T} may be obtained from the finite element nodal basis relaxation matrix \\mathbf{R} by","category":"page"},{"location":"theory/discretization/","page":"Discretization","title":"Discretization","text":"mathbfT = mathbfP^mathsfT mathbfR mathbfP","category":"page"},{"location":"api/#API-Reference","page":"API Reference","title":"API Reference","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Modules = [SpinDoctor]","category":"page"},{"location":"api/#SpinDoctor.SpinDoctor","page":"API Reference","title":"SpinDoctor.SpinDoctor","text":"Diffusion MRI modelling\n\n\n\n\n\n","category":"module"},{"location":"api/#SpinDoctor.AbstractCallback","page":"API Reference","title":"SpinDoctor.AbstractCallback","text":"AbstractCallback\n\nCallback to be performed after every time step when solving the BTPDE. The callback is initialized before time stepping using the initialize! function, updated after every step using update!, and finalized after time stepping using finalize!.\n\n\n\n\n\n","category":"type"},{"location":"api/#SpinDoctor.AbstractGradient","page":"API Reference","title":"SpinDoctor.AbstractGradient","text":"AbstractGradient{T}\n\nMagnetic field gradient vecg(t).\n\n\n\n\n\n","category":"type"},{"location":"api/#SpinDoctor.CosOGSE","page":"API Reference","title":"SpinDoctor.CosOGSE","text":"f = CosOGSE(δ, Δ, nperiod)\n\nOscillating Gradient Spin Echo sequence with two cos-pulses of duration δ separated by a pause of duration Δ-δ for nperiod periods per pulse.\n\n\n\n\n\n","category":"type"},{"location":"api/#SpinDoctor.DoublePGSE","page":"API Reference","title":"SpinDoctor.DoublePGSE","text":"f = DoublePGSE(δ, Δ)\n\nDouble Pulsed Gradient Spin Echo sequence with four pulses of duration δ, separated by pauses of duration Δ-δ, 0, and Δ-δ repsectively.\n\n\n\n\n\n","category":"type"},{"location":"api/#SpinDoctor.GeneralGradient","page":"API Reference","title":"SpinDoctor.GeneralGradient","text":"GeneralGradient(g⃗)\n\nGeneral gradient sequence g⃗(t) ∈ R³. The direction and amplitude may vary in time.\n\n\n\n\n\n","category":"type"},{"location":"api/#SpinDoctor.Model","page":"API Reference","title":"SpinDoctor.Model","text":"Model(mesh, ρ, D, T₂, κ, γ)\n\nDiscretized biological model with initial spin densities ρ, diffusion tensors D, T₂-relaxation times T₂, wall permeabilities κ, and gyromacnetic ratio γ (defaults to the one of water protons).\n\n\n\n\n\n","category":"type"},{"location":"api/#SpinDoctor.PGSE","page":"API Reference","title":"SpinDoctor.PGSE","text":"f = PGSE(δ, Δ)\n\nPulsed Gradient Spin Echo sequence with pulse duration δ and time between pulses Δ-δ.\n\n\n\n\n\n","category":"type"},{"location":"api/#SpinDoctor.Plotter","page":"API Reference","title":"SpinDoctor.Plotter","text":"Plotter(; nupdate = 1)\n\nPlot the evolution of the BTPDE during time stepping. This requires loading the GLMakie plotting backend (]add GLMakie; using GLMakie). The plot is updated every nupdate time step. The resulting figure contains a plot of the time profile, total signal attenuation, and magnetization field (complex magnitude and phase shift).\n\n\n\n\n\n","category":"type"},{"location":"api/#SpinDoctor.Printer","page":"API Reference","title":"SpinDoctor.Printer","text":"Printer(; nupdate = 1)\n\nPrint time stepping information to the console.\n\n\n\n\n\n","category":"type"},{"location":"api/#SpinDoctor.ScalarGradient","page":"API Reference","title":"SpinDoctor.ScalarGradient","text":"ScalarGradient(dir, profile, amplitude)\n\nGradient sequence with amplitude amplitude, normal direction dir and scalar time profile profile.\n\nThe direction is constant, while the amplitude is controlled by the time profile.\n\nThe direction is normalized upon construction.\n\n\n\n\n\n","category":"type"},{"location":"api/#SpinDoctor.SinOGSE","page":"API Reference","title":"SpinDoctor.SinOGSE","text":"f = SinOGSE(δ, Δ, nperiod)\n\nOscillating Gradient Spin Echo sequence with two sin-pulses of duration δ separated by a pause of duration Δ-δ for nperiod periods per pulse.\n\n\n\n\n\n","category":"type"},{"location":"api/#SpinDoctor.TimeProfile","page":"API Reference","title":"SpinDoctor.TimeProfile","text":"TimeProfile\n\nGeneral time profile type (gradient sequence).\n\nA TimeProfile should implement a calling method returning the value of the time profile at time t. It can optionally overwrite the echotime integral, and int_F² methods, the first providing a default value and the latter two computing numerical approximation to the integral quantities if not overwritten.\n\n\n\n\n\n","category":"type"},{"location":"api/#SpinDoctor.TimeProfile-Tuple{Any}","page":"API Reference","title":"SpinDoctor.TimeProfile","text":"ft = (f::TimeProfile)(t)\n\nReturn the time profile value at time t.\n\n\n\n\n\n","category":"method"},{"location":"api/#SpinDoctor.VTKWriter","page":"API Reference","title":"SpinDoctor.VTKWriter","text":"VTKWriter(; nupdate = 1, dir = \"output\", filename = \"solution\")\n\nWrite magnetization field to a VTK file after every nupdate timestep. The files are stored in a ParaView data collection file (PVD). The magnetization time series may be visualized in ParaView by opening the file \"$dir/$filename.pvd\". The compartments are labeled.\n\n\n\n\n\n","category":"type"},{"location":"api/#SpinDoctor.assemble_flux_matrices-Tuple{Any, Any}","page":"API Reference","title":"SpinDoctor.assemble_flux_matrices","text":"assemble_flux_matrices(points, facets)\n\nAssemble flux matrix (Q) for each compartment and boundary.\n\n\n\n\n\n","category":"method"},{"location":"api/#SpinDoctor.assemble_flux_matrix","page":"API Reference","title":"SpinDoctor.assemble_flux_matrix","text":"assemble_flux_matrix(facets, nodes[, weights])\n\nAssemble 3D flux matrix using P1 finite elements.\n\nThis function is based on the Matlab function flux_matrixP1_3D.m from the Matlab nodal matrix assembly toolbox by Jan Valdman and Talal Rahman.\n\nhttps://uk.mathworks.com/matlabcentral/fileexchange/27826-fast-fem-assembly-nodal-elements\n\nTalal Rahman and Jan Valdman: Fast MATLAB assembly of FEM matrices in 2D and 3D: nodal elements, Applied Mathematics and Computation 219, 7151–7158 (2013).\n\n\n\n\n\n","category":"function"},{"location":"api/#SpinDoctor.assemble_mass_matrix","page":"API Reference","title":"SpinDoctor.assemble_mass_matrix","text":"assemble_mass_matrix(elements, volumes[, weights])\n\nAssemble 3D mass matrix using P1 finite elements.\n\nThis function is based on the Matlab function mass_matrixP1_3D.m from the Matlab nodal matrix assembly toolbox by Jan Valdman and Talal Rahmnan:\n\nhttps://uk.mathworks.com/matlabcentral/fileexchange/27826-fast-fem-assembly-nodal-elements\n\nTalal Rahman and Jan Valdman: Fast MATLAB assembly of FEM matrices in 2D and 3D: nodal elements, Applied Mathematics and Computation 219, 7151–7158 (2013).\n\n\n\n\n\n","category":"function"},{"location":"api/#SpinDoctor.assemble_matrices-Tuple{Any}","page":"API Reference","title":"SpinDoctor.assemble_matrices","text":"assemble_matrices(model)\n\nAssemble finite element matrices.\n\n\n\n\n\n","category":"method"},{"location":"api/#SpinDoctor.assemble_stiffness_matrix","page":"API Reference","title":"SpinDoctor.assemble_stiffness_matrix","text":"assemble_stiffness_matrix(elements, nodes[, D])\n\nAssemble 3D stiffness matrix using P1 finite elements. A diffusion tensor D may be provided.\n\nThis function is based on the Matlab function stiffness_matrixP1_3D.m from the Matlab nodal matrix assembly toolbox by Jan Valdman and Talal Rahman.\n\nhttps://uk.mathworks.com/matlabcentral/fileexchange/27826-fast-fem-assembly-nodal-elements\n\nTalal Rahman and Jan Valdman: Fast MATLAB assembly of FEM matrices in 2D and 3D: nodal elements, Applied Mathematics and Computation 219, 7151–7158 (2013).\n\n\n\n\n\n","category":"function"},{"location":"api/#SpinDoctor.call_tetgen-Tuple{Any, Any}","page":"API Reference","title":"SpinDoctor.call_tetgen","text":"call_tetgen(surfaces, refinement)\n\nCall Tetgen on surface geometry. A refinement is applied if refinement < Inf.\n\n\n\n\n\n","category":"method"},{"location":"api/#SpinDoctor.coefficients","page":"API Reference","title":"SpinDoctor.coefficients","text":"coefficients(setup; D, T₂, ρ, κ, γ)\n\nPrepare PDE compartments.\n\n\n\n\n\n","category":"function"},{"location":"api/#SpinDoctor.compute_adc_sta-Union{Tuple{T}, Tuple{Model{T}, ScalarGradient}} where T","page":"API Reference","title":"SpinDoctor.compute_adc_sta","text":"compute_adc_sta(model)\n\nCompute the ADC for each compartment in the short diffusion time regime.\n\n\n\n\n\n","category":"method"},{"location":"api/#SpinDoctor.compute_areas-Tuple{Any, Any}","page":"API Reference","title":"SpinDoctor.compute_areas","text":"compute_areas(facets, nodes)\n\nCompute facet areas.\n\n\n\n\n\n","category":"method"},{"location":"api/#SpinDoctor.compute_mf_diffusion_tensor-Tuple{Any, Any, Any, ScalarGradient}","page":"API Reference","title":"SpinDoctor.compute_mf_diffusion_tensor","text":"compute_mf_diffusion_tensor(mesh, M, lap_eig, gradient::ScalarGradient)\n\nCompute effective diffusion tensors using the matrix formalism.\n\n\n\n\n\n","category":"method"},{"location":"api/#SpinDoctor.compute_signal-Tuple{Any, Any}","page":"API Reference","title":"SpinDoctor.compute_signal","text":"compute_signal(M, ξ) = sum(M * ξ)\n\nCompute signal from magnetization ξ, using the mass matrix M for integration.\n\nGiven a mesh mesh and a vector of compartment mass matrices M_cmpts, a vector of compartment signals may be obtained by compute_signal.(M_cmpts, split_field(mesh, ξ)).\n\n\n\n\n\n","category":"method"},{"location":"api/#SpinDoctor.compute_∇φ-Tuple{Any, Any}","page":"API Reference","title":"SpinDoctor.compute_∇φ","text":"compute_∇φ(nodes, points)\n\nCompute the gradients of the finite element basis functions φ.\n\n\n\n\n\n","category":"method"},{"location":"api/#SpinDoctor.convexhull-Tuple{Any}","page":"API Reference","title":"SpinDoctor.convexhull","text":"elements, points = convexhull(points)\n\nCompute the convex hull of a set of points points (of size dim * npoint). Return a matrix of boundary elements elements (of sizedim * nelement) and a restriction of the original points to the boundary (size dim * npoint_keep).\n\n\n\n\n\n","category":"method"},{"location":"api/#SpinDoctor.couple_flux_matrix","page":"API Reference","title":"SpinDoctor.couple_flux_matrix","text":"couple_flux_matrix(model, Q_blocks[, symmetrical])\n\nCreate global flux matrix with coupling between compartments.\n\n\n\n\n\n","category":"function"},{"location":"api/#SpinDoctor.create_cells-Tuple{Any}","page":"API Reference","title":"SpinDoctor.create_cells","text":"create_cells(setup)\n\nCreate geometrical configuration of cells. Return mathematical description (radii, centers).\n\n\n\n\n\n","category":"method"},{"location":"api/#SpinDoctor.create_fibonacci_sphere-Tuple{Any}","page":"API Reference","title":"SpinDoctor.create_fibonacci_sphere","text":"create_fibonacci_sphere(npoint)\n\nCreate npoint evenly distributed points on the sphere.\n\n\n\n\n\n","category":"method"},{"location":"api/#SpinDoctor.create_geometry-Tuple{Any}","page":"API Reference","title":"SpinDoctor.create_geometry","text":"create_geometry(setup; recreate = true)\n\nCreate cells, surfaces and finite element mesh. If recreate = false, previous geometry will be reused.\n\nThis function does the following:\n\nCheck geometry setup consistency\nCreate or load cell configuration\nCreate or load surface triangulation\nCall TetGen\nDeform domain\nSplit mesh into compartments\n\nFor custom geometries with more than one compartment, call split_mesh directly instead. This requires facet and element labels.\n\n\n\n\n\n","category":"method"},{"location":"api/#SpinDoctor.create_surfaces-Tuple{CylinderSetup, Any}","page":"API Reference","title":"SpinDoctor.create_surfaces","text":"create_surfaces(setup::CylinderSetup, cells)\n\nCreate surface triangulation of [inner and] outer cylinders [and ECS].\n\nThe ground surface is triangulated first, before the walls are \"extruded\" and the top surface is copied from the ground surface.\n\n\n\n\n\n","category":"method"},{"location":"api/#SpinDoctor.create_surfaces-Tuple{SphereSetup, Any}","page":"API Reference","title":"SpinDoctor.create_surfaces","text":"create_surfaces(setup::SphereSetup, cells)\n\nCreate surface triangulation of [inner and] outer spheres [and ECS].\n\n\n\n\n\n","category":"method"},{"location":"api/#SpinDoctor.create_surfaces-Union{Tuple{T}, Tuple{NeuronSetup{T}, Any}} where T","page":"API Reference","title":"SpinDoctor.create_surfaces","text":"create_surfaces(setup::NeuronSetup, filename)\n\nCreate neuron surface mesh. A neuron surface mesh is loaded or create and loaded. An ECS can be added.\n\n\n\n\n\n","category":"method"},{"location":"api/#SpinDoctor.create_surfaces-Union{Tuple{T}, Tuple{PlateSetup{T}, Any}} where T","page":"API Reference","title":"SpinDoctor.create_surfaces","text":"create_surfaces(setup::PlateSetup, cells)\n\nCreate surface triangulation of a collection of stacked plates.\n\n\n\n\n\n","category":"method"},{"location":"api/#SpinDoctor.diffusion_time","page":"API Reference","title":"SpinDoctor.diffusion_time","text":"diffusion_time(f)\n\nDiffusion time of time profile f.\n\n\n\n\n\n","category":"function"},{"location":"api/#SpinDoctor.diffusion_time_sta","page":"API Reference","title":"SpinDoctor.diffusion_time_sta","text":"diffusion_time_sta(f)\n\nGet the short term approximation of the diffusion time of the time profile f.\n\n\n\n\n\n","category":"function"},{"location":"api/#SpinDoctor.echotime-Tuple{GeneralGradient}","page":"API Reference","title":"SpinDoctor.echotime","text":"echotime(gradient)\n\nGet echo time TE of gradient.\n\n\n\n\n\n","category":"method"},{"location":"api/#SpinDoctor.echotime-Tuple{SpinDoctor.TimeProfile}","page":"API Reference","title":"SpinDoctor.echotime","text":"echotime(f)\n\nGet echo time TE of the time profile f, which is the end of the last characteristic interval.\n\n\n\n\n\n","category":"method"},{"location":"api/#SpinDoctor.eig2length-Tuple{Any, Any}","page":"API Reference","title":"SpinDoctor.eig2length","text":"eig2length(λ, D)\n\nConvert Laplace eigenvalue to length scale.\n\n\n\n\n\n","category":"method"},{"location":"api/#SpinDoctor.fit_adc-Tuple{Any, Any}","page":"API Reference","title":"SpinDoctor.fit_adc","text":"fit_adc(bvalues, signals)\n\nFit the apparent diffusion coefficient (ADC) using a polynomial logfit of the normalized signals signals against the b-values bvalues.\n\n\n\n\n\n","category":"method"},{"location":"api/#SpinDoctor.fit_tensors-Tuple{Any, Any}","page":"API Reference","title":"SpinDoctor.fit_tensors","text":"fit_tensors(directions, adcs)\n\nFit effective diffusion tensors to directionalized ADCs. The six components of the symmetric diffusion tensors are fitted by least squares to the gradient directions and resulting ADCs.\n\n\n\n\n\n","category":"method"},{"location":"api/#SpinDoctor.fresnelc-Tuple{Any}","page":"API Reference","title":"SpinDoctor.fresnelc","text":"fresnelc(x)\n\nCompute the Fresnel C integral of type 0 (integral of cos(πt²/2)).\n\n\n\n\n\n","category":"method"},{"location":"api/#SpinDoctor.fresnels-Tuple{Any}","page":"API Reference","title":"SpinDoctor.fresnels","text":"fresnels(x)\n\nCompute the Fresnel S integral of type 0 (integral of sin(πt²/2)).\n\n\n\n\n\n","category":"method"},{"location":"api/#SpinDoctor.get_cmpt_volumes-Tuple{Any}","page":"API Reference","title":"SpinDoctor.get_cmpt_volumes","text":"get_cmpt_volumes(mesh)\n\nGet compartment volumes.\n\n\n\n\n\n","category":"method"},{"location":"api/#SpinDoctor.get_mesh_surface-Tuple{Any, Any}","page":"API Reference","title":"SpinDoctor.get_mesh_surface","text":"get_mesh_surface(points, facets)\n\nCompute surface areas, centers and normals for each facet.\n\n\n\n\n\n","category":"method"},{"location":"api/#SpinDoctor.get_mesh_surfacenormals-Tuple{Any, Any, Any}","page":"API Reference","title":"SpinDoctor.get_mesh_surfacenormals","text":"get_mesh_surfacenormals(points, elements, facets)\n\nComputing outwards oriented surface normals on a connected mesh compartment.\n\n\n\n\n\n","category":"method"},{"location":"api/#SpinDoctor.get_mesh_volumes-Tuple{Any, Any}","page":"API Reference","title":"SpinDoctor.get_mesh_volumes","text":"get_mesh_volumes(points, elements)\n\nGet total volume and volumes of each tetrahedron of mesh.\n\n\n\n\n\n","category":"method"},{"location":"api/#SpinDoctor.gmesh2fem-Tuple{Any}","page":"API Reference","title":"SpinDoctor.gmesh2fem","text":"gmesh2fem(filename)\n\nExtract points and elements from Gmesh file.\n\n\n\n\n\n","category":"method"},{"location":"api/#SpinDoctor.initial_conditions-Tuple{Any}","page":"API Reference","title":"SpinDoctor.initial_conditions","text":"initial_conditions(model)\n\nGet initial conditions at all degrees of freedom.\n\n\n\n\n\n","category":"method"},{"location":"api/#SpinDoctor.int_F²-Union{Tuple{SpinDoctor.TimeProfile{T}}, Tuple{T}} where T","page":"API Reference","title":"SpinDoctor.int_F²","text":"b = int_F²(f)\n\nCompute the time profile contribution to the b-value. To obtain the b-value, multiply the result by q^2 = (γg)^2, where γ is the gyromagnetic ratio of the water proton, g is the gradient amplitude, and b = q^2 * int_F²(f).\n\n\n\n\n\n","category":"method"},{"location":"api/#SpinDoctor.integral","page":"API Reference","title":"SpinDoctor.integral","text":"integral(f, t = echotime(f))\n\nIntegral of time profile f between 0 and t. Unless specified, the echotime is used as the upper integral limit.\n\nFor the PGSE, SinOGSE, CosOGSE and DoublePGSE sequences, analytical expressions are available. Otherwise a numerical integral is computed.\n\n\n\n\n\n","category":"function"},{"location":"api/#SpinDoctor.intervals","page":"API Reference","title":"SpinDoctor.intervals","text":"intervals(f)\n\nGet characteristic intervals of the time profile f.\n\n\n\n\n\n","category":"function"},{"location":"api/#SpinDoctor.isconstant-Tuple{SpinDoctor.TimeProfile}","page":"API Reference","title":"SpinDoctor.isconstant","text":"isconstant(profile)\n\nReturn true if the time profile profile is intervalwise constant.\n\n\n\n\n\n","category":"method"},{"location":"api/#SpinDoctor.j_integral","page":"API Reference","title":"SpinDoctor.j_integral","text":"j_integral(f, λ)\n\nCompute the integral\n\n``j(f, \\lambda) = \\lambda \\frac{\\int_0^{T_\\text{echo}} F(t) \\int_0^t\ne^{-\\lambda(t - s)} f(s) \\, \\mathrm{d} s \\, \\mathrm{d} t}{\\int_0^{T_\\text{echo}}\nF^2(t) \\, \\mathrm{d} t}``\n\nfor the time profile f and Laplace eigenvalue λ.\n\n\n\n\n\n","category":"function"},{"location":"api/#SpinDoctor.length2eig-Tuple{Any, Any}","page":"API Reference","title":"SpinDoctor.length2eig","text":"length2eig(length, D)\n\nConvert length scale to Laplace eigenvalue.\n\n\n\n\n\n","category":"method"},{"location":"api/#SpinDoctor.limit_lengthscale-Tuple{Any, Any}","page":"API Reference","title":"SpinDoctor.limit_lengthscale","text":"limit_lengthscale(lap_eig, λ_max)\n\nOnly keep modes with length scales larger than minimum\n\n\n\n\n\n","category":"method"},{"location":"api/#SpinDoctor.output_type","page":"API Reference","title":"SpinDoctor.output_type","text":"output_type(problem)\n\nGet type returned by solve(problem).\n\n\n\n\n\n","category":"function"},{"location":"api/#SpinDoctor.plot_field-Tuple{SpinDoctor.FEMesh, Any}","page":"API Reference","title":"SpinDoctor.plot_field","text":"plot_field(femesh, ξ)\n\nPlot field ξ on the finite element mesh.\n\n\n\n\n\n","category":"method"},{"location":"api/#SpinDoctor.plot_mesh-Tuple{SpinDoctor.FEMesh}","page":"API Reference","title":"SpinDoctor.plot_mesh","text":"plot_mesh(femesh)\n\nPlot finite element mesh.\n\n\n\n\n\n","category":"method"},{"location":"api/#SpinDoctor.radial_dimension","page":"API Reference","title":"SpinDoctor.radial_dimension","text":"radial_dimension(setup)\n\nGet dimension of radial direction.\n\n\n\n\n\n","category":"function"},{"location":"api/#SpinDoctor.read_cells-Tuple{Any}","page":"API Reference","title":"SpinDoctor.read_cells","text":"read_cells(cellfilename)\n\nRead cell configuration (centers and radii).\n\n\n\n\n\n","category":"method"},{"location":"api/#SpinDoctor.read_surfaces-Tuple{Any}","page":"API Reference","title":"SpinDoctor.read_surfaces","text":"read_surfaces(filename)\n\nRead surface triangulation from file.\n\n\n\n\n\n","category":"method"},{"location":"api/#SpinDoctor.read_tetgen-Tuple{Any}","page":"API Reference","title":"SpinDoctor.read_tetgen","text":"read_tetgen\n\nRead mesh from Tetgen.\n\n\n\n\n\n","category":"method"},{"location":"api/#SpinDoctor.save_cells-Tuple{Any, Any}","page":"API Reference","title":"SpinDoctor.save_cells","text":"save_cells(cells, cellfilename)\n\nWrite geometrical cell configuration to file. The file contains the spatial dimension: 2 for cylinders, 3 for spheres.\n\n\n\n\n\n","category":"method"},{"location":"api/#SpinDoctor.save_surfaces-Tuple{Any, Any}","page":"API Reference","title":"SpinDoctor.save_surfaces","text":"save_surfaces(filename, surfaces)\n\nSave surface triangulation. The files may be passed to Tetgen with filename.node.\n\n\n\n\n\n","category":"method"},{"location":"api/#SpinDoctor.save_tetgen-Tuple{Any, Any}","page":"API Reference","title":"SpinDoctor.save_tetgen","text":"save_tetgen(mesh_all, filename)\n\nSave mesh in the Tetgen output format.\n\n\n\n\n\n","category":"method"},{"location":"api/#SpinDoctor.shapeder-Tuple{Any}","page":"API Reference","title":"SpinDoctor.shapeder","text":"shapeder(points)\n\nDerivative of shape functions with respect to reference coordinates (ξ₁, ξ₂, ξ₃).\n\n\n\n\n\n","category":"method"},{"location":"api/#SpinDoctor.solve","page":"API Reference","title":"SpinDoctor.solve","text":"solve\n\nSolve problem.\n\n\n\n\n\n","category":"function"},{"location":"api/#SpinDoctor.solve-Tuple{AnalyticalMatrixFormalism, ScalarGradient}","page":"API Reference","title":"SpinDoctor.solve","text":"solve(problem::AnalyticalMatrixFormalism, gradient, volumes = nothing)\n\nCompute the signal in a multilayered cylinder or sphere using an analytical matrix formalism solution.\n\nThis function is based on the following articles and corresponding code:     [1] D. S. Grebenkov, NMR Survey of Reflected Brownian Motion,         Rev. Mod.Phys. 79, 1077 (2007)     [2] D. S. Grebenkov, Pulsed-gradient spin-echo monitoring of restricted diffusion in         multilayered structures, J. Magn. Reson. 205, 181-195 (2010).\n\n\n\n\n\n","category":"method"},{"location":"api/#SpinDoctor.solve-Tuple{HADC, ScalarGradient}","page":"API Reference","title":"SpinDoctor.solve","text":"solve_hadc(problem::HADC, gradient::ScalarGradient)\n\nCompute the ADC using a homogenized ADC model (HADC). This is currently only implemented for scalar gradients.\n\n\n\n\n\n","category":"method"},{"location":"api/#SpinDoctor.solve-Tuple{Karger, ScalarGradient}","page":"API Reference","title":"SpinDoctor.solve","text":"solve(problem::Karger, gradient)\n\nSolve the finite pulse Karger model (FPK) using precomputed effective diffusion tensors difftensors.\n\n\n\n\n\n","category":"method"},{"location":"api/#SpinDoctor.solve-Tuple{Laplace}","page":"API Reference","title":"SpinDoctor.solve","text":"solve(laplace::Laplace)\n\nCompute the Laplace eigenvalues, eigenfunctions and first order moments of products of pairs of eigenfunctions.\n\n\n\n\n\n","category":"method"},{"location":"api/#SpinDoctor.solve-Tuple{MatrixFormalism, Any}","page":"API Reference","title":"SpinDoctor.solve","text":"solve(problem::MatrixFormalism, matrices, lap_eig, gradient)\n\nSolve for magnetization using Matrix Formalism.\n\n\n\n\n\n","category":"method"},{"location":"api/#SpinDoctor.solve-Union{Tuple{T}, Tuple{GeneralBTPDE{T}, Any}} where T","page":"API Reference","title":"SpinDoctor.solve","text":"solve(problem::GeneralBTPDE, gradient[; callbacks])\n\nSolve the Bloch-Torrey partial differential equation using P1 finite elements.\n\n\n\n\n\n","category":"method"},{"location":"api/#SpinDoctor.solve-Union{Tuple{T}, Tuple{IntervalConstanBTPDE{T}, ScalarGradient}} where T","page":"API Reference","title":"SpinDoctor.solve","text":"run(problem::IntervalConstanBTPDE, gradient)\n\nSolve the Bloch-Torrey partial differential equation using P1 finite elements. This function uses a manual time stepping scheme (theta-rule), that requires a degree of implicitness θ and a time step Δt.     θ = 0.5: Crank-Nicolson (second order)     θ = 1.0: Implicit Euler (first order)\n\n\n\n\n\n","category":"method"},{"location":"api/#SpinDoctor.solve_multigrad-Tuple{Any, Any}","page":"API Reference","title":"SpinDoctor.solve_multigrad","text":"solve_multigrad(problem, gradients)\n\nSolve problem for multiple magnetic field gradients.\n\n\n\n\n\n","category":"method"},{"location":"api/#SpinDoctor.split_field-Tuple{Any, Any}","page":"API Reference","title":"SpinDoctor.split_field","text":"split_field(mesh, ξ)\n\nSplit the field ξ into a vector containing a view of each compartment. \n\n\n\n\n\n","category":"method"},{"location":"api/#SpinDoctor.unitcircle-Tuple{Any}","page":"API Reference","title":"SpinDoctor.unitcircle","text":"unitcircle(ndirection; half = false, normal = [0, 0, 1])\n\nCreate ndirection directions unformly distributed on the unit circle defined by normal.\n\nIf half is true, the directions lie on a half-circle instead of the whole circle. \n\n\n\n\n\n","category":"method"},{"location":"api/#SpinDoctor.unitsphere-Tuple{Any}","page":"API Reference","title":"SpinDoctor.unitsphere","text":"unitsphere(ndirection; half = false, normal = [0, 0, 1])\n\nCreate ndirection directions unformly distributed on the unit sphere.\n\nIf half is true, the points will be discributed on the hemisphere defined by normal.\n\n\n\n\n\n","category":"method"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Model\nPGSE","category":"page"},{"location":"theory/adc/#Apparent-diffusion-coefficient","page":"ADC","title":"Apparent diffusion coefficient","text":"","category":"section"},{"location":"theory/adc/","page":"ADC","title":"ADC","text":"Consider a unidirectional gradient vecg(t) = g f(t) vecd parametrized by an amplitude g  0, time profile f  0 T_textecho to -1 1 and direction vecd with  vecd  = 1.","category":"page"},{"location":"theory/adc/","page":"ADC","title":"ADC","text":"Some commonly used time profiles (diffusion-encoding sequences) are:","category":"page"},{"location":"theory/adc/","page":"ADC","title":"ADC","text":"The pulsed-gradient spin echo (PGSE) sequence:\nf(t) =\nbegincases\n1 quad  t_1 leq t leq t_1+delta \n-1 quad  t_1 + Delta  t leq t_1 + Delta + delta \n0 quad  textotherwise\nendcases\nThe double pulsed-gradient spin echo (DPGSE) sequence:\nf(t) = f_delta Delta(t) + f_delta Deltaleft(t - (Delta + delta +\nt_textpause) right)\nwhere f_delta Delta is a normal PGSE sequence;\nThe oscillating gradient spin echo (OGSE) sequence (here, cos-OGSE):\nf(t) =\nbegincases\n    cosleft(n frac2pidelta (t - t_1)right) quad  t_1  t leq t_1\n    + delta \n    -cosleft(n frac2 pidelta (t - Delta - t_1)right) quad  t_1 + Delta  t\n    leq t_1 + Delta + delta \n    0 quad  textotherwise\nendcases","category":"page"},{"location":"theory/adc/","page":"ADC","title":"ADC","text":"where t_1 geq 0 and t_1 + Delta geq T_textecho  2.","category":"page"},{"location":"theory/adc/#B-value","page":"ADC","title":"B-value","text":"","category":"section"},{"location":"theory/adc/","page":"ADC","title":"ADC","text":"In a DMRI experiment, f is usually fixed, while g or vecd are varied. S is usually plotted against a quantity called the b-value. The b-value depends on vecg:","category":"page"},{"location":"theory/adc/","page":"ADC","title":"ADC","text":"b(vecg f) = gamma^2 vecg^2 int_0^T_textecho  mathrmdtleft(int_0^t\nf(s)mathrmdsright)^2","category":"page"},{"location":"theory/adc/","page":"ADC","title":"ADC","text":"For PGSE, the b-value is:","category":"page"},{"location":"theory/adc/","page":"ADC","title":"ADC","text":"b(vecgdeltaDelta) = gamma^2 vecg^2 delta^2 left(Delta - delta3right)","category":"page"},{"location":"theory/adc/","page":"ADC","title":"ADC","text":"For the cosine OGSE with \\emph{integer}\\/ number of periods n in each of the two durations delta, the corresponding b-value is:","category":"page"},{"location":"theory/adc/","page":"ADC","title":"ADC","text":"b(vecgdelta) = gamma^2 vecg^2 fracdelta^34 n^2 pi^2 = gamma^2\nvecg^2 fracdeltaomega^2","category":"page"},{"location":"theory/adc/","page":"ADC","title":"ADC","text":"The reason for these definitions is that in a homogeneous medium, the signal attenuation is euler^-vecd^transpose matD_0 vecd b, where matD is the intrinsic diffusion tensor and vecd = vecg  vecg.","category":"page"},{"location":"theory/adc/#ADC","page":"ADC","title":"ADC","text":"","category":"section"},{"location":"theory/adc/","page":"ADC","title":"ADC","text":"An important quantity that can be derived from the dMRI signal is the \"Apparent Diffusion Coefficient\" (ADC), which gives an indication of the root mean squared distance travelled by water molecules in the gradient direction vecgvecg, averaged over all starting positions:","category":"page"},{"location":"theory/adc/","page":"ADC","title":"ADC","text":"D_textADC = left -fracpartialpartial b logfracS(b)S(0)rightvert_b=0","category":"page"},{"location":"theory/adc/#Fitting-the-ADC-from-the-dMRI-signal","page":"ADC","title":"Fitting the ADC from the dMRI signal","text":"","category":"section"},{"location":"theory/adc/","page":"ADC","title":"ADC","text":"We numerically compute ADC by a polynomial fit of","category":"page"},{"location":"theory/adc/","page":"ADC","title":"ADC","text":"logfracS(b)S_textinitial approx c_0+c_1b+dots+c_n b^n","category":"page"},{"location":"theory/adc/","page":"ADC","title":"ADC","text":"increasing n from 1 onwards until we get the value of c_1 to be stable within a numerical tolerance, where S_textinitial = int_Omega rho(vecx)  mathrmd Omega(vecx). The first coefficient is given by c_0 = log fracS(0)S_textinitial, which is equal to zero if T_2i = infty for all i.","category":"page"},{"location":"theory/adc/","page":"ADC","title":"ADC","text":"The ADC may be interpreted as a correction to the intrinsic diffusion coefficient, taking into account the deviation from the free diffusion arising from interior interfaces, non-isotropic diffusion, fluid movements etc. For suffiently small b-values, the signal attenuation is given by","category":"page"},{"location":"theory/adc/","page":"ADC","title":"ADC","text":"mathrme^-D_textADC b","category":"page"},{"location":"theory/adc/","page":"ADC","title":"ADC","text":"Another quantity of interest is a slight generalization of the ADC–-an effective diffusion tensor mathbfD_texteff. The six coefficients of this symmetric positive tensor is fitted to best approximate the following signal attenuation, for all gradients vecg in mathbbR^3:","category":"page"},{"location":"theory/adc/","page":"ADC","title":"ADC","text":"mathrme^- fracvecg^mathsfT mathbfD_texteff vecgvecg^mathsfT\nvecg b","category":"page"},{"location":"theory/adc/","page":"ADC","title":"ADC","text":"The resulting ADC in direction vecd is then given by","category":"page"},{"location":"theory/adc/","page":"ADC","title":"ADC","text":"D_textADC(vecg) = fracvecg^mathsfT mathbfD_texteff\nvecgvecg^mathsfT vecg = vecd^mathsfT mathbfD_texteff vecd","category":"page"},{"location":"theory/adc/#HADC","page":"ADC","title":"HADC","text":"","category":"section"},{"location":"theory/adc/","page":"ADC","title":"ADC","text":"In a previous work, a PDE model for the time-dependent ADC was obtained starting from the Bloch-Torrey equation, using homogenization techniques. In the case of negligible water exchange between compartments (low permeability), there is no coupling between the compartments, at least to the quadratic order in g, which is the ADC term. The ADC in compartment Omega is given by","category":"page"},{"location":"theory/adc/","page":"ADC","title":"ADC","text":"    D_textHADC(vecg f) = vecd^transpose matD vecd -\n    fracint_0^T_textecho F(t) h(t)  mathrmdtint_0^T_textecho F(t)^2 \n    mathrmd t","category":"page"},{"location":"theory/adc/","page":"ADC","title":"ADC","text":"where F(t) = int_0^t f(s)  mathrmds and","category":"page"},{"location":"theory/adc/","page":"ADC","title":"ADC","text":"    h(t) = frac1Omega int_partial Omega omega(vecx t)  vecd cdot\n    vecn(vecx)  mathrmd Gamma(vecx)","category":"page"},{"location":"theory/adc/","page":"ADC","title":"ADC","text":"is a quantity related to the directional gradient of a function omega that is the solution of the homogeneous diffusion equation with Neumann boundary condition and zero initial condition:","category":"page"},{"location":"theory/adc/","page":"ADC","title":"ADC","text":"beginalignedat2\n    fracpartialpartial t omega(vecx t)  = nabla cdot left(matD nabla\n    omega(vecx t)right) quad   (vecx t) in Omega times 0 T_textecho\n    \n    omega(vecx 0)  = 0 quad   vecx in Omega \n    matD nabla omega(vecx t) cdot vecn  = F(t) matD vecd cdot\n    vecn quad    vecx in partial Omega\nendalignedat","category":"page"},{"location":"theory/adc/","page":"ADC","title":"ADC","text":"vecn being the outward normal. The above set of equations comprise the homogenized model that we call the HADC model.","category":"page"},{"location":"theory/adc/#Short-diffusion-time-approximation","page":"ADC","title":"Short diffusion time approximation","text":"","category":"section"},{"location":"theory/adc/","page":"ADC","title":"ADC","text":"A well-known formula for the ADC in the short diffusion time regime is the following short time approximation (STA):","category":"page"},{"location":"theory/adc/","page":"ADC","title":"ADC","text":"    D_textSTA = left(1 - frac4sqrtD_03 sqrtpisqrtDelta fracAd V right) D_0","category":"page"},{"location":"theory/adc/","page":"ADC","title":"ADC","text":"where dfracAV is the surface to volume ratio, d is the spatial dimension and D_0 = vecd^transpose matD vecd is the intrinsic diffusion coefficient in the gradient direction. In the above formula, the pulse duration delta is assumed to be very small compared to Delta. A recent correction to the above formula , taking into account the finite pulse duration delta and the gradient direction vecd, is the following:","category":"page"},{"location":"theory/adc/","page":"ADC","title":"ADC","text":"    D_textSTA = left(1 - frac4 sqrtD_03 sqrtpi\n    C_deltaDelta\n    fracA_vecdV right) D_0","category":"page"},{"location":"theory/adc/","page":"ADC","title":"ADC","text":"where","category":"page"},{"location":"theory/adc/","page":"ADC","title":"ADC","text":"    A_vecd = int_partial Omega left(vecd cdot vecn(vecx)right)^2 \n    mathrmd Gamma(vecx) = vecd^transpose matN vecd","category":"page"},{"location":"theory/adc/","page":"ADC","title":"ADC","text":"with matN = int_partial Omega vecn(vecx) vecn^transpose(vecx)  mathrmd Gamma(vecx) and","category":"page"},{"location":"theory/adc/","page":"ADC","title":"ADC","text":"C_delta Delta = dfrac435 dfracleft(Delta + delta right)^7  2+\nleft(Delta - deltaright)^7  2 - 2 left(delta^ 7  2 + Delta^7  2\nright)delta^2 left( Delta - delta  3right) = sqrtDelta left(1 + dfrac13\ndfracdeltaDelta - dfrac835 left(dfracdeltaDeltaright)^3  2 + dots\nright)","category":"page"},{"location":"theory/adc/","page":"ADC","title":"ADC","text":"When delta ll Delta, the value C_delta Delta is approximately sqrtDelta.","category":"page"},{"location":"getting_started/#Getting-started","page":"Getting Started","title":"Getting started","text":"","category":"section"},{"location":"getting_started/#Installation","page":"Getting Started","title":"Installation","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"To install SpinDoctor, run the following commands:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"git clone https://github.com/agdestein/SpinDoctor.jl\ncd SpinDoctor.jl\njulia --project\n]instantiate","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"The last line takes you into the package mode (]). The instantiate command then installs all dependencies.","category":"page"},{"location":"examples/hardi/#High-angular-resolution-diffusion-imaging","page":"High Angular Resolution","title":"High angular resolution diffusion imaging","text":"","category":"section"},{"location":"examples/hardi/","page":"High Angular Resolution","title":"High Angular Resolution","text":"HARDI","category":"page"},{"location":"examples/hardi/","page":"High Angular Resolution","title":"High Angular Resolution","text":"using SpinDoctor","category":"page"},{"location":"theory/btpde/#Bloch-Torrey-partial-differential-equation","page":"BTPDE","title":"Bloch-Torrey partial differential equation","text":"","category":"section"},{"location":"theory/btpde/","page":"BTPDE","title":"BTPDE","text":"In diffusion MRI, a time-varying magnetic field gradient vecg  0 T_textecho to mathbbR^3 is applied to the tissue to encode water diffusion. The resulting complex transverse water proton magnetization in the rotating frame satisfies the Bloch-Torrey PDE:","category":"page"},{"location":"theory/btpde/","page":"BTPDE","title":"BTPDE","text":"fracpartialpartial t M_i(vecxt) = -left(-nabla cdot mathbfD_i nabla +\nfrac1T_2i + underlinemathrmi gamma vecg(t) cdot vecxright)\nM_i(vecx t)","category":"page"},{"location":"theory/btpde/","page":"BTPDE","title":"BTPDE","text":"where","category":"page"},{"location":"theory/btpde/","page":"BTPDE","title":"BTPDE","text":"vecx in Omega_i,\nt in 0 T_textecho where T_textecho is the echo time at which the signal is measured,\ngamma = 267513times 10^8  mathrmrad  s^-1 T^-1 is the gyromagnetic ratio of the water proton,\nunderlinemathrmi is the imaginary unit,\nmathbfD_i is the intrinsic diffusion tensor in Omega_i,\nT_2i is the T_2-relaxation time in Omega_i, and\nM_i is the magnetization in Omega_i.","category":"page"},{"location":"theory/btpde/","page":"BTPDE","title":"BTPDE","text":"The initial conditions are given by","category":"page"},{"location":"theory/btpde/","page":"BTPDE","title":"BTPDE","text":"M_i(vecx 0) = rho_i in mathbbC quad i in 1 dots N_textcmpt","category":"page"},{"location":"theory/btpde/","page":"BTPDE","title":"BTPDE","text":"where rho_i is the initial spin density in Omega_i. The outer boundary conditions are given by","category":"page"},{"location":"theory/btpde/","page":"BTPDE","title":"BTPDE","text":"mathbfD_i nabla M_i(vecx t) cdot vecn_i(vecx) = -kappa_i M_i(vecx t)\nquad vecx in Gamma_i quad i in 1 dots N_textcmpt","category":"page"},{"location":"theory/btpde/","page":"BTPDE","title":"BTPDE","text":"and the interface conditions by","category":"page"},{"location":"theory/btpde/","page":"BTPDE","title":"BTPDE","text":"mathbfD_i nabla M_i(vecx t) cdot vecn_i(vecx) = -mathbfD_j nabla\nM_j(vecx t) cdot vecn_j(vecx) quad vecx in Gamma_i j quad (i j) in\n1 dots N_textcmpt^2","category":"page"},{"location":"theory/btpde/","page":"BTPDE","title":"BTPDE","text":"mathbfD_i nabla M_i(vecx t) cdot vecn_i(vecx) = kappa_i j left(c_i j\nM_j(vecx t) - c_j i M_i(vecx t)right) quad vecx in Gamma_i j quad (i\nj) in 1 dots N_textcmpt^2","category":"page"},{"location":"theory/btpde/","page":"BTPDE","title":"BTPDE","text":"where","category":"page"},{"location":"theory/btpde/","page":"BTPDE","title":"BTPDE","text":"vecn_i is the unit outward pointing normal vector of Omega_i\nkappa_i is a boundary relaxation coefficient for Omega_i,\nkappa_i j = kappa_j i is the permeability coefficient on Gamma_i j,\nc_i j and c_j i account for the spin density equilibrium between the two compartments, with either\nc_i j = c_j i = 1, in which case a uniform spin density across compartments is favored in the absence of a gradient, or\nc_i j = frac2 rho_irho_i + rho_j and c_j i = frac2 rho_jrho_i + rho_j, which ensures that the non-uniform intitial spin density is preserved in the absence of a gradient.","category":"page"},{"location":"theory/btpde/","page":"BTPDE","title":"BTPDE","text":"The diffusion MRI signal is measured at echo time t = T_textecho. This signal is computed as the spatial integral of the final magnetization M(cdot T_textecho):","category":"page"},{"location":"theory/btpde/","page":"BTPDE","title":"BTPDE","text":"S(vecg) = int_Omega M(vecx T_textecho)  mathrmd Omega(vecx)","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = SpinDoctor","category":"page"},{"location":"#SpinDoctor","page":"Home","title":"SpinDoctor","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This is the documentation for SpinDoctor, and is based on the SpinDoctor User Guide.","category":"page"},{"location":"","page":"Home","title":"Home","text":"SpinDoctor is a software package that performs numerical simulations of diffusion magnetic resonance imaging (dMRI) for prototyping purposes.","category":"page"},{"location":"","page":"Home","title":"Home","text":"SpinDoctor can be used","category":"page"},{"location":"","page":"Home","title":"Home","text":"to solve the Bloch-Torrey partial differential equation (BTDPE) to obtain the dMRI signal (the toolbox provides a way of robustly fitting the dMRI signal to obtain the fitted Apparent Diffusion Coefficient (ADC));\nto solve the diffusion equation for the homogenized ADC (HADC) model to obtain the ADC;\na short-time approximation formula for the ADC is also included in the toolbox for comparison with the simulated ADC;\nCompute the dMRI signal using a matrix formalism (MF) analytical solution based Laplace eigenfunctions.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The PDEs and Laplace eigenvalue decompositions are solved by P1 finite elements. The geometry recipes create surface triangulations that are passed to TetGen to perform the finite element mesh generation.","category":"page"},{"location":"","page":"Home","title":"Home","text":"SpinDoctor has support for the following features:","category":"page"},{"location":"","page":"Home","title":"Home","text":"multiple compartments connected through permeable membranes, with different\ninitial spin densities,\ndiffusion tensors,\nT2-relaxation, and\npermeability coefficients for the BTPDE and MF (the HADC assumes negligible permeability);\ndiffusion-encoding gradient pulse sequences, including\nthe pulsed gradient spin echo sequence (PGSE),\nthe double-PGSE,\nthe oscillating gradient spin echo (OGSE), and\ncustom three-dimensional pulse sequences g(t) = (gx(t), gy(t), gz(t));\nuniformly distributed gradient directions in 2D and 3D for high angular resolution diffusion imaging (HARDI).","category":"page"},{"location":"","page":"Home","title":"Home","text":"SpinDoctor also comes with a geometry generation module, allowing for","category":"page"},{"location":"","page":"Home","title":"Home","text":"spherical cells with a nucleus;\ncylindrical cells with a myelin layer;\nan extra-cellular space (ECS) enclosed in either a box, a convex hull, or a tight wrapping around the cells;\ndeformation of canonical cells by bending and twisting.","category":"page"},{"location":"","page":"Home","title":"Home","text":"In addition, a variety of neuron meshes is available, whose surface geometries were extracted from NeuroMopho.org. The neurons may also be enclosed in an extracellular space as described above.","category":"page"}]
}
