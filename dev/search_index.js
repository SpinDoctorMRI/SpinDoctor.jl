var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = SpinDoctor","category":"page"},{"location":"#SpinDoctor","page":"Home","title":"SpinDoctor","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for SpinDoctor.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [SpinDoctor]","category":"page"},{"location":"#SpinDoctor.SpinDoctor","page":"Home","title":"SpinDoctor.SpinDoctor","text":"Diffusion MRI modelling\n\n\n\n\n\n","category":"module"},{"location":"#SpinDoctor.CosOGSE","page":"Home","title":"SpinDoctor.CosOGSE","text":"f = CosOGSE(δ, Δ, nperiod)\n\nOscillating Gradient Spin Echo sequence with two cos-pulses of duration δ separated by a pause of duration Δ-δ for nperiod periods per pulse.\n\n\n\n\n\n","category":"type"},{"location":"#SpinDoctor.DoublePGSE","page":"Home","title":"SpinDoctor.DoublePGSE","text":"f = DoublePGSE(δ, Δ)\n\nDouble Pulsed Gradient Spin Echo sequence with four pulses of duration δ, separated by pauses of duration Δ-δ, 0, and Δ-δ repsectively.\n\n\n\n\n\n","category":"type"},{"location":"#SpinDoctor.PGSE","page":"Home","title":"SpinDoctor.PGSE","text":"f = PGSE(δ, Δ)\n\nPulsed Gradient Spin Echo sequence with pulse duration δ and time between pulses Δ-δ.\n\n\n\n\n\n","category":"type"},{"location":"#SpinDoctor.SinOGSE","page":"Home","title":"SpinDoctor.SinOGSE","text":"f = SinOGSE(δ, Δ, nperiod)\n\nOscillating Gradient Spin Echo sequence with two sin-pulses of duration δ separated by a pause of duration Δ-δ for nperiod periods per pulse.\n\n\n\n\n\n","category":"type"},{"location":"#SpinDoctor.TimeProfile","page":"Home","title":"SpinDoctor.TimeProfile","text":"General time profile type (gradient sequence).\n\nA TimeProfile should implement a calling method returning the value of the time profile at time t. It can optionally overwrite the echotime integral, and bvalue_no_q methods, the first providing a default value and the latter two computing numerical approximation to the integral quantities if not overwritten.\n\n\n\n\n\n","category":"type"},{"location":"#SpinDoctor.TimeProfile-Tuple{Any}","page":"Home","title":"SpinDoctor.TimeProfile","text":"ft = (f::TimeProfile)(t)\n\nReturn the time profile value at time t.\n\n\n\n\n\n","category":"method"},{"location":"#SpinDoctor.assemble_flux_matrices-Tuple{Any, Any}","page":"Home","title":"SpinDoctor.assemble_flux_matrices","text":"assemble_flux_matrices(points, facets)\n\nAssemble flux matrix (Q) for each compartment and boundary.\n\n\n\n\n\n","category":"method"},{"location":"#SpinDoctor.assemble_flux_matrix","page":"Home","title":"SpinDoctor.assemble_flux_matrix","text":"assemble_flux_matrix(facets, nodes[, weights])\n\nAssemble 3D flux matrix using P1 finite elements.\n\nThis function is based on the Matlab function flux_matrixP1_3D.m from the Matlab nodal matrix assembly toolbox by Jan Valdman and Talal Rahman.\n\nhttps://uk.mathworks.com/matlabcentral/fileexchange/27826-fast-fem-assembly-nodal-elements\n\nTalal Rahman and Jan Valdman: Fast MATLAB assembly of FEM matrices in 2D and 3D: nodal elements, Applied Mathematics and Computation 219, 7151–7158 (2013).\n\n\n\n\n\n","category":"function"},{"location":"#SpinDoctor.assemble_mass_matrix","page":"Home","title":"SpinDoctor.assemble_mass_matrix","text":"assemble_mass_matrix(elements, volumes[, weights])\n\nAssemble 3D mass matrix using P1 finite elements.\n\nThis function is based on the Matlab function mass_matrixP1_3D.m from the Matlab nodal matrix assembly toolbox by Jan Valdman and Talal Rahmnan:\n\nhttps://uk.mathworks.com/matlabcentral/fileexchange/27826-fast-fem-assembly-nodal-elements\n\nTalal Rahman and Jan Valdman: Fast MATLAB assembly of FEM matrices in 2D and 3D: nodal elements, Applied Mathematics and Computation 219, 7151–7158 (2013).\n\n\n\n\n\n","category":"function"},{"location":"#SpinDoctor.assemble_stiffness_matrix","page":"Home","title":"SpinDoctor.assemble_stiffness_matrix","text":"assemble_stiffness_matrix(elements, nodes[, D])\n\nAssemble 3D stiffness matrix using P1 finite elements. A diffusion tensor D may be provided.\n\nThis function is based on the Matlab function stiffness_matrixP1_3D.m from the Matlab nodal matrix assembly toolbox by Jan Valdman and Talal Rahman.\n\nhttps://uk.mathworks.com/matlabcentral/fileexchange/27826-fast-fem-assembly-nodal-elements\n\nTalal Rahman and Jan Valdman: Fast MATLAB assembly of FEM matrices in 2D and 3D: nodal elements, Applied Mathematics and Computation 219, 7151–7158 (2013).\n\n\n\n\n\n","category":"function"},{"location":"#SpinDoctor.bvalue_no_q-Union{Tuple{TimeProfile{T}}, Tuple{T}} where T","page":"Home","title":"SpinDoctor.bvalue_no_q","text":"b = bvalue_no_q(f)\n\nCompute the time profile contribution to the b-value. To obtain the b-value, multiply the result by q^2 = (γg)^2, where γ is the gyromagnetic ratio of the water proton, g is the gradient amplitude, and b = q^2 * bvalue_no_q(f).\n\n\n\n\n\n","category":"method"},{"location":"#SpinDoctor.call_tetgen","page":"Home","title":"SpinDoctor.call_tetgen","text":"call_tetgen(setup, surfaces)\n\nCall Tetgen on surface geometry.\n\n\n\n\n\n","category":"function"},{"location":"#SpinDoctor.compute_areas-Tuple{Any, Any}","page":"Home","title":"SpinDoctor.compute_areas","text":"compute_areas(facets, nodes)\n\nCompute facet areas.\n\n\n\n\n\n","category":"method"},{"location":"#SpinDoctor.compute_laplace_eig","page":"Home","title":"SpinDoctor.compute_laplace_eig","text":"compute_laplace_eig(mesh, pde, eiglim, neig_max)\n\nCompute the Laplace eigenvalues, eigenfunctions and first order moments of products of pairs of eigenfunctions.\n\n\n\n\n\n","category":"function"},{"location":"#SpinDoctor.compute_∇φ-Tuple{Any, Any}","page":"Home","title":"SpinDoctor.compute_∇φ","text":"compute_∇φ(nodes, points)\n\nCompute the gradients of the finite element basis functions φ.\n\n\n\n\n\n","category":"method"},{"location":"#SpinDoctor.constant_intervals-Tuple{TimeProfile}","page":"Home","title":"SpinDoctor.constant_intervals","text":"markers = constant_intervals(f)\n\nGet markers for constant intervals. Default is false on all intervals.\n\n\n\n\n\n","category":"method"},{"location":"#SpinDoctor.convexhull-Tuple{Any}","page":"Home","title":"SpinDoctor.convexhull","text":"elements, points = convexhull(points)\n\nCompute the convex hull of a set of points points (of size dim * npoint). Return a matrix of boundary elements elements (of sizedim * nelement) and a restriction of the original points to the boundary (size dim * npoint_keep).\n\n\n\n\n\n","category":"method"},{"location":"#SpinDoctor.couple_flux_matrix","page":"Home","title":"SpinDoctor.couple_flux_matrix","text":"couple_flux_matrix(model, Q_blocks[, symmetrical])\n\nCreate global flux matrix with coupling between compartments.\n\n\n\n\n\n","category":"function"},{"location":"#SpinDoctor.create_cells-Tuple{Any}","page":"Home","title":"SpinDoctor.create_cells","text":"create_cells(setup)\n\nCreate geometrical configuration of cells. Return mathematical description (radii, centers).\n\n\n\n\n\n","category":"method"},{"location":"#SpinDoctor.create_directions-Tuple{Int64}","page":"Home","title":"SpinDoctor.create_directions","text":"create_directions(ndirection, flat)\n\nCreate ndirection directions unformly distributed in sphere. If flat is true, the directions lie in the plane instead of on the sphere.\n\n\n\n\n\n","category":"method"},{"location":"#SpinDoctor.create_directions-Tuple{Vector{T} where T}","page":"Home","title":"SpinDoctor.create_directions","text":"create_directions(direction)\n\nGet one normalized direction.\n\n\n\n\n\n","category":"method"},{"location":"#SpinDoctor.create_fibonacci_sphere-Tuple{Any}","page":"Home","title":"SpinDoctor.create_fibonacci_sphere","text":"create_fibonacci_sphere(npoint)\n\nCreate npoint evenly distributed points on the sphere.\n\n\n\n\n\n","category":"method"},{"location":"#SpinDoctor.create_geometry-Tuple{Setup}","page":"Home","title":"SpinDoctor.create_geometry","text":"create_geometry(setup)\n\nCreate cells, surfaces and finite element mesh. This function does the following:\n\nCheck geometry setup consistency\nCreate or load cell configuration\nCreate or load surface triangulation\nCall TetGen\nDeform domain\nSplit mesh into compartments\n\nFor custom geometries with more than one compartment, call split_mesh directly instead. This requires facet and element labels.\n\n\n\n\n\n","category":"method"},{"location":"#SpinDoctor.create_surfaces_cylinder-Tuple{Any, Setup}","page":"Home","title":"SpinDoctor.create_surfaces_cylinder","text":"create_surfaces_cylinder(cells, setup)\n\nCreate surface triangulation of [inner and] outer cylinders [and ECS].\n\nThe ground surface is triangulated first, before the walls are \"extruded\" and the top surface is copied from the ground surface.\n\n\n\n\n\n","category":"method"},{"location":"#SpinDoctor.create_surfaces_neuron-Tuple{Any, Setup}","page":"Home","title":"SpinDoctor.create_surfaces_neuron","text":"create_surfaces_neuron(filename, setup)\n\nCreate neuron surface mesh. A neuron surface mesh is loaded or create and loaded. An ECS can be added.\n\n\n\n\n\n","category":"method"},{"location":"#SpinDoctor.create_surfaces_sphere-Tuple{Any, Setup}","page":"Home","title":"SpinDoctor.create_surfaces_sphere","text":"create_surfaces_sphere(cells, setup)\n\nCreate surface triangulation of [inner and] outer spheres [and ECS].\n\n\n\n\n\n","category":"method"},{"location":"#SpinDoctor.echotime-Tuple{TimeProfile}","page":"Home","title":"SpinDoctor.echotime","text":"TE = echotime(f)\n\nGet echo time TE of the time profile f, which is the end of the last characteristic interval.\n\n\n\n\n\n","category":"method"},{"location":"#SpinDoctor.eig2length-Tuple{Any, Any}","page":"Home","title":"SpinDoctor.eig2length","text":"eig2length(λ, D)\n\nConvert Laplace eigenvalue to length scale.\n\n\n\n\n\n","category":"method"},{"location":"#SpinDoctor.fit_adc-Union{Tuple{T}, Tuple{Vector{T}, Vector{T}}} where T<:Real","page":"Home","title":"SpinDoctor.fit_adc","text":"fit_adc(b, S)\n\nFit Apparent Diffusion Coefficient (ADC) using a polynomial logfit of the normalized signal S against the b-values b.\n\n\n\n\n\n","category":"method"},{"location":"#SpinDoctor.fit_tensors-Tuple{Any, Any}","page":"Home","title":"SpinDoctor.fit_tensors","text":"fit_tensors(directions, adc)\n\nFit effective diffusion tensors to directionalized ADCs. The six components of the symmetric diffusion tensors are fitted by least squares to the gradient directions and resulting ADCs.\n\n\n\n\n\n","category":"method"},{"location":"#SpinDoctor.get_cmpt_volumes-Tuple{Any}","page":"Home","title":"SpinDoctor.get_cmpt_volumes","text":"get_cmpt_volumes(mesh)\n\nGet compartment volumes.\n\n\n\n\n\n","category":"method"},{"location":"#SpinDoctor.get_coefficients-Tuple{Any}","page":"Home","title":"SpinDoctor.get_coefficients","text":"get_coefficients(setup)\n\nPrepare PDE compartments.\n\n\n\n\n\n","category":"method"},{"location":"#SpinDoctor.get_interval-Tuple{TimeProfile, Any}","page":"Home","title":"SpinDoctor.get_interval","text":"get_interval(f, t)\n\nGet the characteristic interval number of time profile f containing time t. If intervals[i] ≤ t < intervals[i+1], i is returned.\n\n\n\n\n\n","category":"method"},{"location":"#SpinDoctor.get_mesh_surface-Tuple{Any, Any}","page":"Home","title":"SpinDoctor.get_mesh_surface","text":"get_mesh_surface(points, facets)\n\nCompute surface areas, centers and normals for each facet.\n\n\n\n\n\n","category":"method"},{"location":"#SpinDoctor.get_mesh_surfacenormals-Tuple{Any, Any, Any}","page":"Home","title":"SpinDoctor.get_mesh_surfacenormals","text":"get_mesh_surfacenormals(points, elements, facets)\n\nComputing outwards oriented surface normals on a connected mesh compartment.\n\n\n\n\n\n","category":"method"},{"location":"#SpinDoctor.get_mesh_volumes-Tuple{Any, Any}","page":"Home","title":"SpinDoctor.get_mesh_volumes","text":"get_mesh_volumes(points, elements)\n\nGet total volume and volumes of each tetrahedron of mesh.\n\n\n\n\n\n","category":"method"},{"location":"#SpinDoctor.gmesh2fem-Tuple{Any}","page":"Home","title":"SpinDoctor.gmesh2fem","text":"gmesh2fem(filename)\n\nExtract points and elements from Gmesh file.\n\n\n\n\n\n","category":"method"},{"location":"#SpinDoctor.integral","page":"Home","title":"SpinDoctor.integral","text":"integral(f, t = echotime(f))\n\nIntegral of time profile f between 0 and t. Unless specified, the echotime is used as the upper integral limit.\n\nFor the PGSE, SinOGSE, CosOGSE and DoublePGSE sequences, analytical expressions are available. Otherwise a numerical integral is computed.\n\n\n\n\n\n","category":"function"},{"location":"#SpinDoctor.intervals-Tuple{TimeProfile}","page":"Home","title":"SpinDoctor.intervals","text":"intervals(f)\n\nGet characteristic intervals of the time profile f.\n\n\n\n\n\n","category":"method"},{"location":"#SpinDoctor.is_constant-Tuple{TimeProfile, Any}","page":"Home","title":"SpinDoctor.is_constant","text":"is_constant(f, t)\n\nReturn true if time profile f is constant on the characteristic interval containing or starting at t.\n\n\n\n\n\n","category":"method"},{"location":"#SpinDoctor.length2eig-Tuple{Any, Any}","page":"Home","title":"SpinDoctor.length2eig","text":"length2eig(length, D)\n\nConvert length scale to Laplace eigenvalue.\n\n\n\n\n\n","category":"method"},{"location":"#SpinDoctor.read_cells-Tuple{Any}","page":"Home","title":"SpinDoctor.read_cells","text":"read_cells(cellfilename)\n\nRead cell configuration (centers and radii).\n\n\n\n\n\n","category":"method"},{"location":"#SpinDoctor.read_surfaces-Tuple{Any}","page":"Home","title":"SpinDoctor.read_surfaces","text":"read_surfaces(filename)\n\nRead surface triangulation from file.\n\n\n\n\n\n","category":"method"},{"location":"#SpinDoctor.read_tetgen-Tuple{Any}","page":"Home","title":"SpinDoctor.read_tetgen","text":"read_tetgen\n\nRead mesh from Tetgen.\n\n\n\n\n\n","category":"method"},{"location":"#SpinDoctor.save_cells-Tuple{Any, Any}","page":"Home","title":"SpinDoctor.save_cells","text":"save_cells(cells, cellfilename)\n\nWrite geometrical cell configuration to file. The file contains the spatial dimension: 2 for cylinders, 3 for spheres.\n\n\n\n\n\n","category":"method"},{"location":"#SpinDoctor.save_surfaces-Tuple{Any, Any}","page":"Home","title":"SpinDoctor.save_surfaces","text":"save_surfaces(filename, surfaces)\n\nSave surface triangulation. The files may be passed to Tetgen with filename.node.\n\n\n\n\n\n","category":"method"},{"location":"#SpinDoctor.save_tetgen-Tuple{Any, Any}","page":"Home","title":"SpinDoctor.save_tetgen","text":"save_tetgen(mesh_all, filename)\n\nSave mesh in the Tetgen output format.\n\n\n\n\n\n","category":"method"},{"location":"#SpinDoctor.shapeder-Tuple{Any}","page":"Home","title":"SpinDoctor.shapeder","text":"shapeder(points)\n\nDerivative of shape functions with respect to reference coordinates (ξ₁, ξ₂, ξ₃).\n\n\n\n\n\n","category":"method"},{"location":"#SpinDoctor.solve_analytical","page":"Home","title":"SpinDoctor.solve_analytical","text":"solve_analytical(setup, experiment[, volumes])\n\nCompute the signal in a multilayered cylinder or sphere using an analytical matrix formalism solution.\n\nThis function is based on the following articles and corresponding code:     [1] D. S. Grebenkov, NMR Survey of Reflected Brownian Motion,         Rev. Mod.Phys. 79, 1077 (2007)     [2] D. S. Grebenkov, Pulsed-gradient spin-echo monitoring of restricted diffusion in         multilayered structures, J. Magn. Reson. 205, 181-195 (2010).\n\n\n\n\n\n","category":"function"},{"location":"#SpinDoctor.solve_btpde-Tuple{Model, Experiment}","page":"Home","title":"SpinDoctor.solve_btpde","text":"solve_btpde(model, experiment)\n\nSolve the Bloch-Torrey partial differential equation using P1 finite elements.\n\n\n\n\n\n","category":"method"},{"location":"#SpinDoctor.solve_btpde_midpoint-Tuple{Model, Experiment}","page":"Home","title":"SpinDoctor.solve_btpde_midpoint","text":"solve_btpde_midpoint(model, setup)\n\nSolve the Bloch-Torrey partial differential equation using P1 finite elements. This function uses a manual time stepping scheme (theta-rule), that requires a degree of implicitness θ and a time step dt.     θ = 0.5: Crank-Nicolson (second order)     θ = 1.0: Implicit Euler (first order)\n\n\n\n\n\n","category":"method"},{"location":"#SpinDoctor.solve_hadc-Tuple{Any, Any}","page":"Home","title":"SpinDoctor.solve_hadc","text":"solve_hadc(model, experiment) -> NamedTuple\n\nCompute ADCs using the homogenized ADC model (HADC).\n\n\n\n\n\n","category":"method"},{"location":"#SpinDoctor.solve_karger-Tuple{Any, Any, Any}","page":"Home","title":"SpinDoctor.solve_karger","text":"solve_karger(model, experiment, difftensors)\n\nSolve the finite pulse Karger model (FPK) using precomputed effective diffusion tensors difftensors.\n\n\n\n\n\n","category":"method"},{"location":"#SpinDoctor.solve_mf-Tuple{Any, Any, Any}","page":"Home","title":"SpinDoctor.solve_mf","text":"solve_mf(model, lap_eig, experiment)\n\nSolve for magnetization using Matrix Formalism.\n\n\n\n\n\n","category":"method"}]
}
